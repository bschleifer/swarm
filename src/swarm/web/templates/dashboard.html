{% extends "base.html" %}
{% block title %}Swarm's Bee Hive — Dashboard{% endblock %}

{% block body %}
<div id="test-mode-banner" style="display:none; background:#f59e0b; color:#000; text-align:center; padding:6px 12px; font-weight:bold; font-size:14px;">
    TEST MODE — Supervised orchestration testing active
    <span id="test-report-link" style="display:none; margin-left:12px;"></span>
</div>
<div id="update-banner" style="display:none; background:#362415; border-bottom:2px solid var(--leaf); padding:8px 16px; font-size:13px; color:var(--text); text-align:center;">
    <span id="update-banner-text"></span>
    <button onclick="installUpdate()" style="margin-left:12px; padding:2px 10px; background:var(--leaf); color:#000; border:none; border-radius:4px; cursor:pointer; font-size:12px; font-weight:600;">Update &amp; Restart</button>
    <button onclick="hideUpdateBanner()" style="margin-left:6px; padding:2px 10px; background:transparent; color:var(--muted); border:1px solid var(--muted); border-radius:4px; cursor:pointer; font-size:12px;">Dismiss</button>
</div>
<header>
    <h1><img src="/static/bees/happy.svg" alt="" class="header-icon"><span class="ws-indicator" id="ws-dot"></span> Swarm's Bee Hive <span id="header-clock" class="header-clock"></span></h1>
    <div class="flex-center gap-md">
        <div class="status" id="status-bar">
            {{ worker_count }} workers
        </div>
        <span id="queen-queue-badge" class="notification-badge bg-lavender" style="display:none" title="Queen calls: running/total"></span>
        <button class="btn {{ 'btn-active' if drones_enabled else 'btn-secondary' }}" id="drones-btn"
                onclick="toggleDrones()">
            Drones: {{ 'ON' if drones_enabled else 'OFF' }}
        </button>
        <button class="btn {{ 'btn-active' if tunnel.running else 'btn-secondary' }} header-hide-mobile" id="tunnel-btn"
                onclick="tunnelAction()">
            Tunnel{{ ': ON' if tunnel.running else '' }}
        </button>
        <button class="btn btn-secondary header-hide-mobile" onclick="showLaunch()">Launch</button>
        <a href="/config" class="btn btn-secondary no-underline header-hide-mobile">Config</a>
        <!-- Attach button removed: PTY model has no full-session view -->
        <button class="btn btn-queen header-hide-mobile" onclick="askQueen()" id="queen-btn" title="Ask Queen to analyze the hive">Ask Queen</button>
        <button class="btn btn-secondary btn-notif header-hide-mobile" id="notif-perm-btn" onclick="requestNotifPermission()" title="Enable buzz alerts">&#x1f514;</button>
        <button class="btn btn-danger header-hide-mobile" onclick="killSession()" title="Shutdown — kill all workers">Shutdown</button>
        <!-- Mobile overflow menu -->
        <div class="mobile-overflow">
            <button class="mobile-overflow-btn" onclick="toggleMobileMenu(event)" aria-label="More actions">&#x2630;</button>
            <div class="mobile-overflow-menu" id="mobile-overflow-menu">
                <button class="btn btn-secondary" onclick="tunnelAction();closeMobileMenu()">Tunnel</button>
                <button class="btn btn-secondary" onclick="showLaunch();closeMobileMenu()">Launch</button>
                <a href="/config" class="btn btn-secondary no-underline">Config</a>
                <!-- Attach button removed: PTY model has no full-session view -->
                <button class="btn btn-queen" onclick="askQueen();closeMobileMenu()">Ask Queen</button>
                <button class="btn btn-danger" onclick="killSession();closeMobileMenu()">Shutdown</button>
            </div>
        </div>
    </div>
</header>

<div class="dashboard">
    <!-- Queen notification banners (non-blocking, replaces modal popups) -->
    <div id="queen-notifications"></div>

    <!-- Worker sidebar -->
    <div class="panel worker-list">
        <div class="panel-header">Workers</div>
        <div class="panel-body" id="worker-list">
            {% include "partials/worker_list.html" %}
        </div>
        <div class="action-bar">
            <button class="btn btn-secondary" onclick="continueAll()">Continue All</button>
            <button class="btn btn-secondary" onclick="showBroadcast()">Broadcast</button>
        </div>
    </div>

    <!-- Detail area -->
    <div class="detail-area">
        <div class="panel">
            <div class="panel-header" id="detail-title">Select a worker</div>
            <div class="panel-body" id="detail-body">
                <p class="text-muted modal-padding">Click a worker to see details</p>
            </div>
            <!-- Mobile send bar (touch devices only) -->
            <div class="mobile-send-bar" id="mobile-send-bar" style="display:none">
                <input type="text" id="mobile-send-input" placeholder="Type or dictate..."
                       enterkeyhint="send"
                       onkeydown="if(event.key==='Enter'){event.preventDefault();mobileSend()}">
                <button class="btn btn-sm" onclick="mobileSend()">Send</button>
            </div>
            <!-- Action bar (shown when a worker is selected) -->
            <div class="action-bar" id="terminal-actions" style="display:none">
                {% for btn in action_buttons %}
                <button type="button"
                        class="btn btn-{{ btn.style }}{% if not btn.show_mobile %} hide-mobile{% endif %}{% if not btn.show_desktop %} hide-desktop{% endif %}"
                        onclick="doAction('{{ btn.action }}', {{ btn.command|tojson|forceescape }})">{{ btn.label }}</button>
                {% endfor %}
                <button type="button" class="btn btn-secondary hide-mobile" id="btn-fullscreen-term" onclick="openTerminalFullscreen()" style="display:none">Fullscreen</button>
            </div>
        </div>

        <!-- Drag handle -->
        <div class="resize-handle" id="resize-handle"></div>

        <!-- Bottom tabbed panel -->
        <div class="panel bottom-tabbed">
            <div class="panel-header panel-header-flush">
                <div class="tab-group">
                    <button class="tab-btn active" id="tab-tasks-btn" onclick="switchTab('tasks')">
                        Tasks
                    </button>
                    <button class="tab-btn" id="tab-decisions-btn" onclick="switchTab('decisions')">
                        Decisions
                        <span id="proposal-badge" class="notification-badge bg-lavender" style="display:{% if proposal_count %}inline-flex{% else %}none{% endif %}">{{ proposal_count }}</span>
                    </button>
                    <button class="tab-btn" id="tab-buzz-btn" onclick="switchTab('buzz')">
                        Buzz Log <span id="notif-badge" class="notification-badge" style="display:none">0</span>
                    </button>
                </div>
                <span class="flex-center gap-sm">
                    <button class="btn btn-sm" onclick="showCreateTask()">+ New Task</button>
                </span>
            </div>
            <!-- Tasks tab -->
            <div class="tab-content active drop-zone" id="tab-tasks"
                 ondragenter="event.preventDefault();event.dataTransfer.dropEffect='copy';this.style.borderColor='var(--lavender)';"
                 ondragover="event.preventDefault();event.dataTransfer.dropEffect='copy';"
                 ondragleave="this.style.borderColor='';"
                 ondrop="handleEmailDrop(event);this.style.borderColor='';"
                 >
                <div class="filter-bar" id="task-filters">
                    <button class="filter-chip active" data-filter="all" onclick="switchTaskFilter('all')">All</button>
                    <button class="filter-chip" data-filter="pending" onclick="switchTaskFilter('pending')">Pending</button>
                    <button class="filter-chip" data-filter="assigned" onclick="switchTaskFilter('assigned')">Active</button>
                    <button class="filter-chip" data-filter="completed" onclick="switchTaskFilter('completed')">Done</button>
                    <button class="filter-chip" data-filter="failed" onclick="switchTaskFilter('failed')">Failed</button>
                    <span class="filter-separator"></span>
                    <button class="filter-chip priority-chip active" data-priority="all" onclick="switchPriorityFilter('all')">All</button>
                    <button class="filter-chip priority-chip" data-priority="low" onclick="switchPriorityFilter('low')">Low</button>
                    <button class="filter-chip priority-chip" data-priority="normal" onclick="switchPriorityFilter('normal')">Normal</button>
                    <button class="filter-chip priority-chip" data-priority="high" onclick="switchPriorityFilter('high')">High</button>
                    <button class="filter-chip priority-chip" data-priority="urgent" onclick="switchPriorityFilter('urgent')">Urgent</button>
                    <input type="text" id="task-search" placeholder="Search tasks..." oninput="debouncedTaskSearch(this.value)" class="task-search">
                </div>
                <div id="task-summary" class="task-summary">{{ task_summary }}</div>
                <div class="panel-body" id="task-list">
                    {% include "partials/task_list.html" %}
                </div>
            </div>
            <!-- Decisions tab — Queen proposals + decision history -->
            <div class="tab-content" id="tab-decisions">
                <!-- Queen Proposals banner -->
                <div id="proposal-banner" class="proposal-banner" style="display:{% if proposals %}block{% else %}none{% endif %};">
                    <div class="proposal-banner-header">
                        <strong class="proposal-banner-title"><img src="/static/bees/queen.svg" class="bee-icon bee-sm" alt="" style="margin-right:0.2rem">Queen Proposals (<span id="proposal-count">{{ proposal_count }}</span>)</strong>
                        <span class="flex-center gap-xs">
                            <button class="btn btn-sm btn-approve btn-proposal" onclick="approveAllProposals()">Approve All</button>
                            <button class="btn btn-sm btn-reject-ghost btn-proposal" onclick="rejectAllProposals()">Dismiss All</button>
                        </span>
                    </div>
                    <div id="proposal-list">
                        {% for p in proposals %}
                        <div class="proposal-item" data-proposal-id="{{ p.id }}"{% if p.proposal_type == 'completion' and p.has_source_email %} data-has-email="1"{% endif %}>
                            {% if p.proposal_type == 'escalation' %}<span class="conf-badge conf-mid">ESC</span>{% endif %}
                            <span class="proposal-worker">{{ p.worker_name }}</span>
                            {% if p.proposal_type == 'escalation' %}<span class="text-beeswax flex-1">{{ p.assessment or p.reasoning }}</span>{% else %}<span class="text-muted">&larr;</span><span class="text-beeswax flex-1">{{ p.task_title }}</span>{% endif %}
                            {% if p.reasoning and p.proposal_type != 'escalation' %}<span class="proposal-reason" title="{{ p.reasoning }}">{{ p.reasoning }}</span>{% endif %}
                            {% set conf_pct = (p.confidence * 100)|int %}<span class="conf-badge {% if conf_pct >= 70 %}conf-high{% elif conf_pct >= 40 %}conf-mid{% else %}conf-low{% endif %}">Confidence: {{ conf_pct }}%</span>
                            <span class="text-muted text-xs">{{ p.age_str }}</span>
                            <button class="btn btn-sm btn-secondary btn-log view-proposal-btn" data-proposal-id="{{ p.id }}">View</button>
                            <button class="btn btn-sm btn-approve btn-proposal" onclick="approveProposal('{{ p.id }}'{% if p.proposal_type == 'completion' and p.has_source_email %}, true{% endif %})">Approve</button>
                            <button class="btn btn-sm btn-reject-ghost btn-proposal" onclick="rejectProposal('{{ p.id }}')">Reject</button>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                <div class="panel-body" id="decisions-log">
                    <div class="empty-state"><img src="/static/bees/queen.svg" class="bee-icon bee-hero" alt=""><div class="mt-sm">No decisions yet</div></div>
                </div>
            </div>
            <!-- Buzz Log — unified activity log -->
            <div class="tab-content" id="tab-buzz">
                <div class="filter-bar" id="buzz-filters">
                    <button class="filter-chip active" data-buzz-cat="all" onclick="switchBuzzFilter('all')">All</button>
                    <button class="filter-chip" data-buzz-cat="drone" onclick="switchBuzzFilter('drone')">Drone</button>
                    <button class="filter-chip" data-buzz-cat="task" onclick="switchBuzzFilter('task')">Task</button>
                    <button class="filter-chip" data-buzz-cat="queen" onclick="switchBuzzFilter('queen')">Queen</button>
                    <button class="filter-chip" data-buzz-cat="worker" onclick="switchBuzzFilter('worker')">Worker</button>
                    <button class="filter-chip" data-buzz-cat="operator" onclick="switchBuzzFilter('operator')">Operator</button>
                    <input type="text" id="buzz-search" placeholder="Search log..." oninput="debouncedBuzzSearch(this.value)" class="task-search">
                </div>
                <div class="panel-body" id="buzz-log"></div>
            </div>
        </div>
    </div>
</div>

<!-- Shortcut bar — keyboard shortcuts -->
<div class="shortcut-bar">
    <span><span class="sc-key">Ctrl+]</span> <span class="sc-label">Next Worker</span></span>
    <span><span class="sc-key">Ctrl+[</span> <span class="sc-label">Prev Worker</span></span>
    <span><span class="sc-key">Alt+B</span> <span class="sc-label">Drones</span></span>
    <span><span class="sc-key">Alt+A</span> <span class="sc-label">Continue All</span></span>
    <span><span class="sc-key">Alt+K</span> <span class="sc-label">Kill</span></span>
    <span><span class="sc-key">Alt+R</span> <span class="sc-label">Revive</span></span>
    <!-- Alt+T Attach removed: PTY model has no full-session view -->
    <span><span class="sc-key">Alt+Q</span> <span class="sc-label">Queen</span></span>
    <span><span class="sc-key">Alt+N</span> <span class="sc-label">New Task</span></span>
    <span><span class="sc-key">Alt+X</span> <span class="sc-label">Quit</span></span>
</div>

<!-- Broadcast modal (hidden) -->
<div id="broadcast-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideBroadcast()">
    <div class="modal-box">
        <div class="panel-header">Broadcast Message</div>
        <div class="modal-padding">
            <label class="form-label">Target</label>
            <select id="broadcast-target"
                    class="modal-select mb-md">
                <option value="__all__">All Workers</option>
                {% for g in groups %}
                <option value="group:{{ g.name }}">Group: {{ g.name }}</option>
                {% endfor %}
            </select>
            <textarea id="broadcast-input" placeholder="Message to send..." rows="4"
                      class="modal-textarea"></textarea>
            <div class="modal-footer modal-footer-flush mt-md">
                <button class="btn btn-secondary" onclick="hideBroadcast()">Cancel</button>
                <button class="btn" onclick="sendBroadcast()">Send</button>
            </div>
        </div>
    </div>
</div>

<!-- Queen control modal (hidden) -->
<div id="queen-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideQueen()">
    <div class="modal-box modal-lg">
        <div class="panel-header btn-queen">
            <span><img src="/static/bees/queen.svg" class="bee-icon bee-md" alt="" style="margin-right:0.3rem">Queen — Hive Conductor</span>
            <button class="btn btn-sm btn-close" onclick="hideQueen()">Close</button>
        </div>
        <div id="queen-result" class="modal-body modal-body-scroll">
            <p class="text-muted">Analyzing hive...</p>
        </div>
        <div class="queen-ask-footer">
            <div class="flex-center gap-sm">
                <input type="text" id="queen-question" placeholder="Ask the Queen a question..."
                       class="modal-input flex-1"
                       onkeydown="if(event.key==='Enter')askQueenQuestion()">
                <button class="btn btn-queen" id="queen-ask-btn" onclick="askQueenQuestion()">Ask</button>
            </div>
            <div class="modal-footer modal-footer-flush">
                <button class="btn btn-secondary" onclick="askQueen()" id="queen-refresh-btn">Re-analyze</button>
                <button class="btn" id="queen-apply-btn" style="display:none" onclick="applyDirectives()">Apply All Directives</button>
            </div>
        </div>
    </div>
</div>
<!-- Launch modal (hidden) -->
<div id="launch-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideLaunch()">
    <div class="modal-box modal-md">
        <div class="panel-header">
            <span><img src="/static/bees/flying-right.svg" class="bee-icon bee-md" alt="" style="margin-right:0.3rem">Launch Brood</span>
            <button class="btn btn-sm btn-secondary" onclick="hideLaunch()">Close</button>
        </div>
        <div id="launch-body" class="modal-body">
            <p class="text-muted">Loading config...</p>
        </div>
        <div class="modal-footer" style="justify-content:space-between">
            <button class="btn btn-secondary btn-sm" onclick="launchAll()">Launch All</button>
            <button class="btn" onclick="launchSelected()">Launch Selected</button>
        </div>
    </div>
</div>
<!-- Spawn worker modal (hidden) -->
<div id="spawn-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideSpawn()">
    <div class="modal-box modal-sm">
        <div class="panel-header">
            <span>Spawn Worker</span>
            <button class="btn btn-sm btn-secondary" onclick="hideSpawn()">Close</button>
        </div>
        <div class="modal-padding">
            <label class="form-label">Worker Name</label>
            <input id="spawn-name" type="text" placeholder="e.g. worker-4"
                   class="modal-input mb-md">
            <label class="form-label">Project Path</label>
            <input id="spawn-path" type="text" placeholder="/home/user/project"
                   class="modal-input mb-sm">
            <div id="spawn-presets" class="mb-md"></div>
            <div class="modal-footer modal-footer-flush">
                <button class="btn btn-secondary" onclick="hideSpawn()">Cancel</button>
                <button class="btn" onclick="doSpawn()">Spawn</button>
            </div>
        </div>
    </div>
</div>
<!-- Unified Task modal — used for both Create and Edit -->
<div id="task-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)closeTaskModal()">
    <div class="modal-box modal-xl">
        <div class="panel-header btn-queen" id="task-modal-header">
            <span id="task-modal-title">New Task</span>
            <button class="btn btn-sm btn-close" onclick="closeTaskModal()">Close</button>
        </div>
        <div class="modal-padding">
            <label class="form-label">Description</label>
            <textarea id="tm-desc" placeholder="Paste your prompt, email, instructions..." rows="24"
                      class="modal-textarea mb-md min-h-textarea"></textarea>
            <label class="form-label">Title <span id="tm-title-hint" class="hint">(optional &mdash; auto-generated from content)</span></label>
            <input id="tm-title" type="text" placeholder="Auto-generated if blank"
                   class="modal-input mb-md">
            <div class="flex-center gap-md mb-md">
                <div>
                    <label class="form-label">Priority</label>
                    <select id="tm-priority"
                            class="modal-select">
                        <option value="normal">Normal</option>
                        <option value="low">Low</option>
                        <option value="high">High</option>
                        <option value="urgent">Urgent</option>
                    </select>
                </div>
                <div>
                    <label class="form-label">Type</label>
                    <select id="tm-task-type"
                            class="modal-select">
                        <option value="">Auto-detect</option>
                        <option value="bug">Bug Fix</option>
                        <option value="verify">Verification</option>
                        <option value="feature">Feature</option>
                        <option value="chore">Chore</option>
                    </select>
                </div>
                <div id="tm-tags-row" class="flex-1">
                    <label class="form-label">Tags (comma-separated)</label>
                    <input id="tm-tags" type="text"
                           class="modal-input">
                </div>
            </div>
            <div class="mb-md">
                <label class="form-label">Depends on <span class="hint">(comma-separated task IDs)</span></label>
                <input id="tm-deps" type="text" placeholder="e.g. a1b2c3d4, e5f6g7h8"
                       class="modal-input">
            </div>
            <div id="tm-resolution-row" class="mb-md" style="display:none;">
                <label class="form-label label-sage">Resolution</label>
                <div id="tm-resolution" class="resolution-display"></div>
            </div>
            <label class="form-label">Attachments</label>
            <div id="tm-dropzone" class="drop-zone-dashed mb-md">
                Drop files here, paste images (Ctrl+V), or click to browse
                <input type="file" id="tm-file" class="hidden" multiple>
            </div>
            <div id="tm-attachments" class="flex-center flex-wrap gap-sm mb-md"></div>
            <div class="modal-footer modal-footer-flush">
                <button class="btn btn-secondary" onclick="closeTaskModal()">Cancel</button>
                <button class="btn" id="tm-submit-btn" onclick="submitTaskModal()">Create</button>
            </div>
        </div>
    </div>
</div>
<!-- Shutdown dialog modal (hidden) -->
<div id="shutdown-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideShutdown()">
    <div class="modal-box modal-sm">
        <div class="panel-header btn-danger">
            <span>Shutdown</span>
            <button class="btn btn-sm btn-close-danger" onclick="hideShutdown()">Close</button>
        </div>
        <div class="modal-body-lg">
            <p class="text-beeswax mb-lg">What would you like to do?</p>
            <div class="modal-stack">
                <button class="btn btn-secondary p-md" onclick="doRestartServer()">Restart Server</button>
                <button class="btn btn-secondary p-md" onclick="doStopServer()">Stop Web App</button>
                <button class="btn btn-danger p-md" onclick="doKillEverything()">Kill Everything</button>
            </div>
        </div>
    </div>
</div>
<!-- Tunnel QR modal (hidden) -->
<div id="tunnel-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideTunnel()">
    <div class="modal-box modal-sm" style="text-align:center">
        <div class="panel-header" style="background:var(--leaf);color:var(--hive-bg)">
            <span>Remote Access</span>
            <button class="btn btn-sm btn-close" onclick="hideTunnel()">Close</button>
        </div>
        <div class="modal-body-lg">
            <div id="tunnel-qr" style="margin:0 auto 1rem;display:inline-block"></div>
            <p id="tunnel-url-text" class="text-beeswax mb-sm" style="word-break:break-all;font-size:0.85rem"></p>
            <div class="modal-actions-center">
                <button class="btn btn-secondary" onclick="copyTunnelUrl()">Copy URL</button>
                <button class="btn btn-danger" onclick="stopTunnel()">Stop Tunnel</button>
            </div>
            <p id="tunnel-warning" class="text-poppy text-xs mt-sm" style="display:none"></p>
        </div>
    </div>
</div>
<!-- Confirm modal (hidden) -->
<div id="confirm-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideConfirm()">
    <div class="modal-box modal-sm">
        <div class="panel-header btn-danger">Confirm</div>
        <div class="modal-body-lg">
            <p id="confirm-msg" class="text-beeswax mb-lg"></p>
            <div class="modal-actions-center">
                <button class="btn btn-secondary" onclick="hideConfirm()">Cancel</button>
                <button class="btn btn-danger" id="confirm-yes-btn">Confirm</button>
            </div>
        </div>
    </div>
</div>
<!-- Decision detail modal -->
<div id="decision-modal" class="modal-overlay" style="display:none" onclick="if(event.target===this)hideDecisionModal()">
    <div class="modal-box modal-md">
        <div class="panel-header" id="decision-modal-header">Decision Detail</div>
        <div class="modal-padding" id="decision-modal-body"></div>
    </div>
</div>
<!-- Terminal modal (hidden) -->
<div id="terminal-modal" class="modal-overlay z-terminal" style="display:none;">
    <div class="terminal-fullscreen">
        <div class="panel-header no-shrink">
            <span id="terminal-title">Terminal</span>
            <span class="flex-center gap-md">
                <span id="terminal-status" class="text-sm text-muted">connecting...</span>
                <button class="btn btn-sm btn-secondary" onclick="closeTerminal()">Close</button>
            </span>
        </div>
        <div id="terminal-container" class="terminal-content"></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css" integrity="sha384-tStR1zLfWgsiXCF3IgfB3lBa8KmBe/lG287CL9WCeKgQYcp1bjb4/+mwN6oti4Co" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.min.js" integrity="sha384-J4qzUjBl1FxyLsl/kQPQIOeINsmp17OHYXDOMpMxlKX53ZfYsL+aWHpgArvOuof9" crossorigin="anonymous" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.min.js" integrity="sha384-XGqKrV8Jrukp1NITJbOEHwg01tNkuXr6uB6YEj69ebpYU3v7FvoGgEg23C1Gcehk" crossorigin="anonymous" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xterm/addon-clipboard@0.2.0/lib/addon-clipboard.min.js" crossorigin="anonymous" defer></script>
<script>
(function() {
    let selectedWorker = null;
    try { selectedWorker = sessionStorage.getItem('swarm_selected_worker') || null; } catch(e) {}
    let ws = null;
    let reconnectTimer = null;
    let reconnectDelay = 1000;
    const MAX_RECONNECT_DELAY = 30000;
    let prevWorkerStates = {}; // track states for STUNG detection

    // Page visibility — title flash state
    let pageHidden = document.hidden;
    let titleFlashTimer = null;
    let pendingTitleCount = 0;
    const ORIGINAL_TITLE = document.title;

    // Terminal cache — keeps xterm.js instances alive across worker switches
    const termCache = new Map();  // workerName → { term, fitAddon, ws, container, connectTimer, reconnectAttempts, reconnectTimer, lastCols, lastRows, lastAccess }
    const MAX_CACHED_TERMS = 10;
    let activeTermWorker = null;
    var MAX_TERM_RECONNECT = 3;
    // Backward-compat aliases — updated on every show/hide so existing code
    // (fullscreen, keyboard shortcuts, mobileSend, etc.) keeps working.
    let inlineTerm = null;
    let inlineTermWs = null;
    let inlineFitAddon = null;
    let inlineTermWorker = null;

    function wsToken() {
        return sessionStorage.getItem('swarm_api_password') || '';
    }

    function wsUrl(path) {
        const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
        let url = proto + '//' + location.host + path;
        const tok = wsToken();
        if (tok) url += (url.includes('?') ? '&' : '?') + 'token=' + encodeURIComponent(tok);
        return url;
    }

    // --- DRY helpers ---

    /** POST to an action endpoint and parse JSON. On success calls onOk(data). */
    function postAction(endpoint, body, onOk) {
        fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: body
        })
        .then(r => r.json())
        .then(data => {
            if (data.error) { showToast('Error: ' + data.error, true); return; }
            onOk(data);
        })
        .catch(() => showToast('Request failed', true));
    }

    /** POST a task action (complete, remove, fail, unassign, reopen). */
    function taskAction(action, taskId, successStatus, successMsg) {
        postAction(
            '/action/task/' + action,
            'task_id=' + encodeURIComponent(taskId),
            function(data) {
                if (data.status === successStatus) {
                    showToast(successMsg);
                    refreshTasks();
                }
            }
        );
    }

    // --- WebSocket ---
    function connect() {
        ws = new WebSocket(wsUrl('/ws'));

        ws.onopen = function() {
            document.getElementById('ws-dot').classList.add('connected');
            reconnectDelay = 1000; // reset on success
            if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        };

        ws.onclose = function() {
            document.getElementById('ws-dot').classList.remove('connected');
            reconnectTimer = setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT_DELAY);
        };

        ws.onmessage = function(e) {
            try {
                const data = JSON.parse(e.data);
                handleEvent(data);
            } catch(err) {}
        };
    }

    function handleEvent(data) {
        switch(data.type) {
            case 'init':
                if (data.test_mode) {
                    isTestMode = true;
                    document.getElementById('test-mode-banner').style.display = 'block';
                }
                if (data.proposals) {
                    renderProposals(data.proposals);
                    updateProposalBadge(data.proposal_count || 0);
                }
                if (data.update && data.update.available) {
                    showUpdateBanner(data.update);
                }
                if (data.queen_queue) {
                    updateQueenQueueBadge(data.queen_queue);
                }
                // fall through to handle workers
            case 'state':
            case 'workers_changed':
                // Detect workers that just went STUNG + prune stale terminals
                if (data.workers) {
                    var liveNames = new Set();
                    data.workers.forEach(function(w) {
                        liveNames.add(w.name);
                        if (w.state === 'STUNG' && prevWorkerStates[w.name] && prevWorkerStates[w.name] !== 'STUNG') {
                            notifyBrowser('Worker Down', w.name + ' exited (STUNG)');
                            destroyTermEntry(w.name);
                        }
                        prevWorkerStates[w.name] = w.state;
                    });
                    pruneStaleTermEntries(liveNames);
                }
                refreshWorkers();
                refreshStatus();
                if (selectedWorker) refreshDetail();
                break;
            case 'drones':
                refreshBuzzLog();
                refreshWorkers();
                break;
            case 'drones_toggled':
                updateDronesButton(data.enabled);
                refreshStatus();
                break;
            case 'escalation':
                showToast(data.worker + ' escalated: ' + data.reason, true, BEE.surprised);
                notifyBrowser('Escalation', data.worker + ': ' + data.reason);
                refreshWorkers();
                refreshBuzzLog();
                break;
            case 'task_assigned':
            case 'task_created':
            case 'task_completed':
                if (data.task) showToast('Task "' + data.task.title + '" ' + data.type.replace('task_', ''), false, data.type === 'task_completed' ? BEE.honeyJar : BEE.flower);
                refreshTasks();
                break;
            case 'task_removed':
                showToast('Task removed');
                refreshTasks();
                break;
            case 'task_failed':
                showToast('Task marked as failed', true, BEE.angry);
                notifyBrowser('Task Failed', data.task ? data.task.title : 'A task was marked as failed');
                refreshTasks();
                break;
            case 'tasks_changed':
                refreshTasks();
                break;
            case 'proposal_created':
                showToast('Queen proposes: ' + (data.proposal ? data.proposal.task_title : 'new assignment'), false, BEE.queen);
                notifyBrowser('Queen Proposal', data.proposal ? data.proposal.worker_name + ' ← ' + data.proposal.task_title : 'New assignment proposal', true);
                refreshProposals();
                // Flash the Decisions badge so users notice even if not on that tab
                switchTab('decisions');
                break;
            case 'proposals_changed':
                renderProposals(data.proposals || []);
                updateProposalBadge(data.pending_count || 0);
                if ((data.pending_count || 0) === 0) { hideQueen(); clearQueenBanners(); }
                refreshDecisions();
                break;
            case 'queen_auto_acted':
                showToast('Queen auto-acted on ' + (data.worker || '?') + ': ' + (data.action || '?'), false, BEE.queen);
                notifyBrowser('Queen Auto-Action', data.worker + ': ' + data.action + ' (' + Math.round((data.confidence||0)*100) + '% confidence)');
                refreshWorkers();
                refreshBuzzLog();
                refreshDecisions();
                break;
            case 'queen_queue':
                updateQueenQueueBadge(data);
                break;
            case 'queen_escalation':
                showQueenBanner('esc', data);
                notifyBrowser('Queen needs your input', data.worker + ': ' + (data.assessment || data.reasoning || 'Escalation requires review'), true);
                break;
            case 'queen_completion':
                showQueenCompletion(data);
                showQueenBanner('done', data);
                notifyBrowser('Task complete', (data.task_title || 'Task') + ' — ' + (data.worker || ''));
                break;
            case 'draft_reply_ok':
                showToast('Draft reply created for: ' + (data.task_title || 'task'), false, BEE.delivering);
                break;
            case 'draft_reply_failed':
                (function() {
                    var container = document.getElementById('toasts');
                    var toast = document.createElement('div');
                    toast.className = 'toast toast-warning';
                    toast.style.display = 'flex';
                    toast.style.alignItems = 'center';
                    toast.style.gap = '0.5rem';
                    var msg = document.createElement('span');
                    msg.textContent = 'Draft reply FAILED: ' + (data.error || 'unknown error');
                    msg.style.flex = '1';
                    toast.appendChild(msg);
                    if (data.task_id) {
                        var btn = document.createElement('button');
                        btn.textContent = 'Retry';
                        btn.className = 'btn btn-sm';
                        btn.style.cssText = 'background:var(--amber);color:var(--hive-bg);font-size:0.7rem;padding:0.15rem 0.5rem;white-space:nowrap;';
                        btn.onclick = function() { retryDraft(data.task_id); toast.remove(); };
                        toast.appendChild(btn);
                    }
                    container.appendChild(toast);
                    setTimeout(function() { toast.remove(); }, 8000);
                    addNotification('Draft reply FAILED: ' + (data.error || 'unknown error'), true);
                })();
                notifyBrowser('Draft Failed', (data.task_title || 'Task') + ': ' + (data.error || ''));
                break;
            case 'task_send_failed':
                showToast('Task send FAILED to ' + (data.worker || '?') + ': ' + (data.task_title || 'task') + ' — returned to pending', true);
                notifyBrowser('Task Send Failed', (data.task_title || 'Task') + ' could not be sent to ' + (data.worker || 'worker'));
                refreshTasks();
                break;
            case 'system_log':
                refreshBuzzLog();
                break;
            case 'tunnel_started':
                updateTunnelButton(true, data.url);
                if (!tunnelActionPending) showToast('Tunnel active: ' + data.url, false, BEE.happy);
                break;
            case 'tunnel_stopped':
                updateTunnelButton(false, '');
                if (!tunnelActionPending) showToast('Tunnel stopped');
                break;
            case 'tunnel_error':
                updateTunnelButton(false, '');
                break;
            case 'config_changed':
            case 'config_file_changed':
                showToast('Config reloaded');
                refreshWorkers();
                refreshStatus();
                break;
            case 'test_mode':
                if (data.enabled) {
                    isTestMode = true;
                    document.getElementById('test-mode-banner').style.display = 'block';
                }
                break;
            case 'test_report_ready':
                (function() {
                    var link = document.getElementById('test-report-link');
                    link.textContent = 'Report ready: ' + (data.path || '');
                    link.style.display = 'inline';
                    showToast('Test report generated: ' + (data.path || ''), false, BEE.honeyJar);
                })();
                break;
            case 'update_available':
                showUpdateBanner(data);
                break;
            case 'update_progress':
                showUpdateProgress(data.line || '');
                break;
            case 'update_failed':
                showToast('Update failed — check logs', true);
                resetUpdateBanner();
                break;
            case 'update_installed':
                showToast('Update installed — restart swarm to use the new version');
                hideUpdateBanner();
                break;
            case 'update_restarting':
                showToast('Update installed — server restarting...');
                hideUpdateBanner();
                waitForRestart();
                break;
        }
    }

    // --- HTMX partial fetchers ---
    function refreshWorkers() {
        htmx.ajax('GET', '/partials/workers' + (selectedWorker ? '?worker=' + selectedWorker : ''), '#worker-list');
    }

    function refreshStatus() {
        htmx.ajax('GET', '/partials/status', '#status-bar');
    }

    var activeTaskFilters = new Set();
    var activePriorityFilters = new Set();
    let activeSearchQuery = '';
    try { activeSearchQuery = localStorage.getItem('swarm_task_search') || ''; } catch(e) {}

    function refreshTasks() {
        let url = '/partials/tasks';
        const params = [];
        if (activeTaskFilters.size) params.push('status=' + Array.from(activeTaskFilters).join(','));
        if (activePriorityFilters.size) params.push('priority=' + Array.from(activePriorityFilters).join(','));
        if (selectedWorker) params.push('worker=' + encodeURIComponent(selectedWorker));
        if (activeSearchQuery) params.push('q=' + encodeURIComponent(activeSearchQuery));
        if (params.length) url += '?' + params.join('&');
        htmx.ajax('GET', url, '#task-list');
    }

    var _searchTimer = null;
    window.debouncedTaskSearch = function(val) {
        activeSearchQuery = val.trim();
        try { localStorage.setItem('swarm_task_search', activeSearchQuery); } catch(e) {}
        if (_searchTimer) clearTimeout(_searchTimer);
        _searchTimer = setTimeout(refreshTasks, 300);
    };

    var activeBuzzCategories = new Set();
    var activeBuzzQuery = '';

    function refreshBuzzLog() {
        var params = [];
        if (activeBuzzCategories.size) {
            params.push('category=' + Array.from(activeBuzzCategories).join(','));
        }
        if (activeBuzzQuery) {
            params.push('q=' + encodeURIComponent(activeBuzzQuery));
        }
        var url = '/partials/system-log';
        if (params.length) url += '?' + params.join('&');
        htmx.ajax('GET', url, '#buzz-log');
    }

    window.switchBuzzFilter = function(cat) {
        if (cat === 'all') {
            activeBuzzCategories.clear();
        } else if (activeBuzzCategories.has(cat)) {
            activeBuzzCategories.delete(cat);
        } else {
            activeBuzzCategories.add(cat);
        }
        document.querySelectorAll('#buzz-filters .filter-chip').forEach(function(b) {
            var c = b.getAttribute('data-buzz-cat');
            if (c === 'all') b.classList.toggle('active', activeBuzzCategories.size === 0);
            else b.classList.toggle('active', activeBuzzCategories.has(c));
        });
        refreshBuzzLog();
    };

    var _buzzSearchTimer = null;
    window.debouncedBuzzSearch = function(val) {
        activeBuzzQuery = val.trim();
        if (_buzzSearchTimer) clearTimeout(_buzzSearchTimer);
        _buzzSearchTimer = setTimeout(refreshBuzzLog, 300);
    };

    // --- Decisions (proposal history) ---
    function refreshDecisions() {
        fetch('/api/decisions?limit=50', { headers: { 'X-Requested-With': 'Dashboard' }})
            .then(function(r) { return r.json(); })
            .then(function(data) { renderDecisions(data.decisions || []); })
            .catch(function() {});
    }

    var _decisionCache = [];
    function renderDecisions(decisions) {
        _decisionCache = decisions;
        var el = document.getElementById('decisions-log');
        if (!el) return;
        if (!decisions.length) {
            el.innerHTML = '<div class="empty-state"><img src="/static/bees/queen.svg" class="bee-icon bee-hero" alt=""><div class="mt-sm">No decisions yet</div></div>';
            return;
        }
        var html = '';
        for (var i = 0; i < decisions.length; i++) {
            var d = decisions[i];
            var ts = new Date(d.created_at * 1000);
            var timeStr = ts.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit', hour12: true});
            var type = d.proposal_type || 'assignment';
            var typeBadge = type === 'escalation' ? 'ESC' : type === 'completion' ? 'DONE' : 'ASSIGN';
            var typeClass = type === 'escalation' ? 'conf-mid' : type === 'completion' ? 'conf-high' : 'bg-lavender';

            var status = d.status || 'approved';
            var outcomeBadge, outcomeClass;
            if (status === 'approved') { outcomeBadge = 'Approved'; outcomeClass = 'conf-high'; }
            else if (status === 'rejected') { outcomeBadge = 'Rejected'; outcomeClass = 'conf-low'; }
            else if (status === 'expired') { outcomeBadge = 'Expired'; outcomeClass = 'conf-mid'; }
            else { outcomeBadge = status; outcomeClass = 'conf-mid'; }

            var confPct = Math.round((d.confidence || 0) * 100);
            var confClass = confPct >= 70 ? 'conf-high' : confPct >= 40 ? 'conf-mid' : 'conf-low';

            var detail = d.assessment || d.reasoning || d.task_title || '';
            if (detail.length > 120) detail = detail.substring(0, 120) + '...';

            html += '<div class="decision-entry" onclick="showDecisionModal(' + i + ')">';
            html += '<span class="text-muted text-xs decision-time">' + timeStr + '</span>';
            html += '<span class="conf-badge ' + typeClass + '">' + typeBadge + '</span>';
            html += '<span class="proposal-worker">' + escapeHtml(d.worker_name) + '</span>';
            if (d.task_title) {
                html += '<span class="text-beeswax flex-1">' + escapeHtml(d.task_title) + '</span>';
            } else {
                html += '<span class="text-beeswax flex-1">' + escapeHtml(detail) + '</span>';
            }
            html += '<span class="conf-badge ' + confClass + '">' + confPct + '%</span>';
            html += '<span class="conf-badge ' + outcomeClass + '">' + outcomeBadge + '</span>';
            html += '<button class="btn btn-sm btn-secondary btn-log" onclick="event.stopPropagation();showDecisionModal(' + i + ')">View</button>';
            html += '</div>';
        }
        el.innerHTML = html;
    }

    window.showDecisionModal = function(idx) {
        var d = _decisionCache[idx];
        if (!d) return;
        var type = d.proposal_type || 'assignment';
        var typeLabel = type === 'escalation' ? 'Escalation' : type === 'completion' ? 'Completion' : 'Assignment';
        var status = (d.status || 'approved');
        var statusLabel = status.charAt(0).toUpperCase() + status.slice(1);
        var confPct = Math.round((d.confidence || 0) * 100);
        var ts = new Date(d.created_at * 1000);
        var timeStr = ts.toLocaleString();

        var hdr = document.getElementById('decision-modal-header');
        var statusClass = status === 'approved' ? 'text-leaf' : status === 'rejected' ? 'text-poppy' : 'text-honey';
        hdr.innerHTML = '<img src="/static/bees/queen.svg" class="bee-icon bee-sm" alt=""> '
            + typeLabel + ' &mdash; <span class="' + statusClass + '">' + statusLabel + '</span>';

        var html = '';
        html += row('Time', escapeHtml(timeStr));
        html += row('Worker', escapeHtml(d.worker_name));
        html += row('Confidence', confPct + '%');
        if (d.task_title) html += row('Task', escapeHtml(d.task_title));
        if (d.queen_action) html += row('Action', escapeHtml(d.queen_action));
        if (d.message) html += row('Message', escapeHtml(d.message));
        if (d.reasoning) html += row('Reasoning', escapeHtml(d.reasoning));
        if (d.assessment) html += row('Assessment', escapeHtml(d.assessment));

        document.getElementById('decision-modal-body').innerHTML = html;
        document.getElementById('decision-modal').style.display = 'flex';

        function row(label, value) {
            return '<div class="decision-detail-row">'
                + '<div class="decision-detail-label">' + label + '</div>'
                + '<div class="decision-detail-value">' + value + '</div></div>';
        }
    };
    window.hideDecisionModal = function() {
        document.getElementById('decision-modal').style.display = 'none';
    };

    // --- Proposals ---
    function refreshProposals() {
        fetch('/api/proposals', { headers: { 'X-Requested-With': 'Dashboard' }})
            .then(function(r) { return r.json(); })
            .then(function(data) {
                renderProposals(data.proposals || []);
                updateProposalBadge(data.pending_count || 0);
            })
            .catch(function() {});
    }

    var _proposalData = {};
    function renderProposals(proposals) {
        var banner = document.getElementById('proposal-banner');
        var list = document.getElementById('proposal-list');
        var countEl = document.getElementById('proposal-count');
        if (!banner || !list) return;
        if (!proposals.length) {
            banner.style.display = 'none';
            return;
        }
        banner.style.display = 'block';
        if (countEl) countEl.textContent = proposals.length;
        var html = '';
        for (var i = 0; i < proposals.length; i++) {
            var p = proposals[i];
            _proposalData[p.id] = p;
            var isEsc = p.proposal_type === 'escalation';
            var isCompletion = p.proposal_type === 'completion';
            var confPct = Math.round((p.confidence || 1.0) * 100);
            var confClass = confPct >= 70 ? 'conf-high' : confPct >= 40 ? 'conf-mid' : 'conf-low';
            var emailAttr = (isCompletion && p.has_source_email) ? ' data-has-email="1"' : '';
            html += '<div class="proposal-item" data-proposal-id="' + escapeHtml(p.id) + '"' + emailAttr + '>';
            if (isEsc) html += '<span class="conf-badge conf-mid">ESC</span>';
            if (isCompletion) html += '<span class="conf-badge conf-high">DONE</span>';
            html += '<span class="proposal-worker">' + escapeHtml(p.worker_name) + '</span>';
            if (isEsc) {
                html += '<span class="text-beeswax flex-1">' + escapeHtml(p.assessment || p.reasoning || 'Escalation') + '</span>';
            } else if (isCompletion) {
                html += '<span class="text-beeswax flex-1">' + escapeHtml(p.task_title) + '</span>';
            } else {
                html += '<span class="text-muted">&larr;</span>';
                html += '<span class="text-beeswax flex-1">' + escapeHtml(p.task_title) + '</span>';
                if (p.reasoning) {
                    html += '<span class="proposal-reason" title="' + escapeHtml(p.reasoning) + '">' + escapeHtml(p.reasoning) + '</span>';
                }
            }
            html += '<span class="conf-badge ' + confClass + '">Confidence: ' + confPct + '%</span>';
            var age = p.age ? (p.age < 60 ? 'just now' : Math.floor(p.age / 60) + 'm ago') : '';
            html += '<span class="text-muted text-xs">' + age + '</span>';
            var hasEmail = isCompletion && p.has_source_email;
            html += '<button class="btn btn-sm btn-secondary btn-log view-proposal-btn" data-proposal-id="' + escapeHtml(p.id) + '">View</button>';
            html += '<button class="btn btn-sm btn-approve" onclick="approveProposal(\'' + escapeHtml(p.id) + '\'' + (hasEmail ? ', true' : '') + ')">Approve</button>';
            html += '<button class="btn btn-sm btn-reject-ghost" onclick="rejectProposal(\'' + escapeHtml(p.id) + '\')">Reject</button>';
            html += '</div>';
        }
        list.innerHTML = html;
    }

    function updateProposalBadge(count) {
        var badge = document.getElementById('proposal-badge');
        if (!badge) return;
        if (count > 0) {
            badge.textContent = count;
            badge.style.display = 'inline-flex';
        } else {
            badge.style.display = 'none';
        }
    }

    function updateQueenQueueBadge(status) {
        var badge = document.getElementById('queen-queue-badge');
        if (!badge) return;
        var running = status.running || 0;
        var queued = status.queued || 0;
        if (running + queued > 0) {
            badge.textContent = queued > 0 ? running + '+' + queued : String(running);
            badge.title = 'Queen: ' + running + ' processing' + (queued > 0 ? ', ' + queued + ' waiting' : '');
            badge.style.display = 'inline-flex';
        } else {
            badge.style.display = 'none';
        }
    }

    window.showProposalDetail = function(proposalId) {
        var p = _proposalData[proposalId];
        if (!p) return;
        if (p.proposal_type === 'escalation') {
            showQueenEscalation({proposal_id:p.id,worker:p.worker_name,assessment:p.assessment||'',reasoning:p.reasoning||'',action:p.queen_action||'',message:p.message||'',confidence:p.confidence||0});
        } else if (p.proposal_type === 'completion') {
            showQueenCompletion({proposal_id:p.id,worker:p.worker_name,task_id:p.task_id||'',task_title:p.task_title||'',assessment:p.assessment||'',reasoning:p.reasoning||'',confidence:p.confidence||0,has_source_email:p.has_source_email||false});
        } else {
            showQueenAssignment(p);
        }
    };

    window.showQueenAssignment = function(data) {
        var modal = document.getElementById('queen-modal');
        var result = document.getElementById('queen-result');
        var confPct = Math.round((data.confidence || 0) * 100);
        var confClass = confPct >= 70 ? 'conf-high' : confPct >= 40 ? 'conf-mid' : 'conf-low';
        var html = '<div class="queen-card queen-card-assign">';
        html += '<div class="queen-card-header">';
        html += '<span class="conf-badge conf-badge-assign"><img src="/static/bees/flying-right.svg" class="bee-icon bee-xs" alt="" style="margin-right:0.2rem">ASSIGN</span>';
        html += '<span class="conf-badge ' + confClass + '">Confidence: ' + confPct + '%</span>';
        html += '</div>';
        html += '<div class="queen-summary">' + queenSummaryLine('assignment', data) + '</div>';
        if (data.reasoning) {
            html += '<div class="mb-sm queen-text-block"><strong class="text-honey">Reasoning</strong><br>' + escapeHtml(data.reasoning) + '</div>';
        }
        if (data.message) {
            html += '<div class="mb-sm"><strong class="text-honey">Message to worker</strong></div>';
            html += '<div class="queen-code-block">' + escapeHtml(data.message) + '</div>';
        }
        html += '</div>';
        if (data.id) {
            html += '<div class="modal-footer">';
            html += '<button class="btn btn-approve" onclick="approveProposal(\'' + escapeHtml(data.id) + '\');hideQueen();">Approve</button>';
            html += '<button class="btn btn-reject-ghost" onclick="rejectProposal(\'' + escapeHtml(data.id) + '\');hideQueen();">Reject</button>';
            html += '</div>';
        }
        result.innerHTML = html;
        modal.style.display = 'flex';
        document.getElementById('queen-apply-btn').style.display = 'none';
        document.querySelector('.queen-ask-footer').style.display = 'none';
        clearTimeout(queenAutoHideTimer);
        if (isTestMode) {
            queenAutoHideTimer = setTimeout(hideQueen, 4000);
        }
    };

    window.approveProposal = function(id, draftResponse) {
        // When called from a completion proposal, read the draft checkbox.
        // If the checkbox isn't in the DOM (e.g. approved from banner, not modal),
        // default to true — the user can opt out via the modal instead.
        if (draftResponse === 'checkbox') {
            var cb = document.getElementById('completion-draft-response');
            draftResponse = cb ? cb.checked : true;
        }
        var body = 'proposal_id=' + encodeURIComponent(id);
        if (draftResponse) body += '&draft_response=true';
        postAction('/action/proposal/approve', body, function(data) {
            if (data.status === 'approved') {
                showToast(draftResponse ? 'Approved — drafting reply' : 'Proposal approved');
                removeQueenBannerByProposal(id);
                refreshProposals();
                refreshTasks();
            }
        });
    };

    window.rejectProposal = function(id) {
        postAction('/action/proposal/reject', 'proposal_id=' + encodeURIComponent(id), function(data) {
            if (data.status === 'rejected') {
                showToast('Proposal rejected');
                removeQueenBannerByProposal(id);
                refreshProposals();
            }
        });
    };

    window.approveAllProposals = function() {
        var rows = document.querySelectorAll('.proposal-item');
        var items = [];
        rows.forEach(function(r) {
            if (r.dataset.proposalId) items.push({ id: r.dataset.proposalId, hasEmail: !!r.dataset.hasEmail });
        });
        var chain = Promise.resolve();
        var failed = 0;
        items.forEach(function(item) {
            chain = chain.then(function() {
                var body = 'proposal_id=' + encodeURIComponent(item.id);
                if (item.hasEmail) body += '&draft_response=true';
                return fetch('/action/proposal/approve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: body
                }).then(function(r) {
                    if (!r.ok) failed++;
                    return r;
                }).catch(function() { failed++; });
            });
        });
        chain.then(function() {
            if (failed) {
                showToast(failed + ' of ' + items.length + ' proposals failed', true);
            } else {
                showToast('All proposals approved');
            }
            refreshProposals();
            refreshTasks();
        }).catch(function() {
            showToast('Approve all failed', true);
            refreshProposals();
        });
    };

    window.rejectAllProposals = function() {
        fetch('/action/proposal/reject-all', { method: 'POST' })
        .then(function(r) { return r.json(); })
        .then(function(data) {
            showToast('Dismissed ' + (data.count || 0) + ' proposal(s)');
            refreshProposals();
        });
    };

    function refreshDetailStatic() {
        if (!selectedWorker) return;
        htmx.ajax('GET', '/partials/detail/' + selectedWorker, '#detail-body');
    }

    window.refreshDetail = function() {
        if (!selectedWorker) return;
        // When inline terminal is live, skip static refresh — it's already live
        if (inlineTerm) return;
        refreshDetailStatic();
    }

    // --- Inline terminal (embedded in detail panel) — cached instances ---

    /** Update backward-compat aliases to point at the active cache entry. */
    function syncTermAliases(entry) {
        if (entry) {
            inlineTerm = entry.term;
            inlineTermWs = entry.ws;
            inlineFitAddon = entry.fitAddon;
            inlineTermWorker = activeTermWorker;
        } else {
            inlineTerm = null;
            inlineTermWs = null;
            inlineFitAddon = null;
            inlineTermWorker = null;
        }
    }

    /** Create a new terminal + cache entry (does NOT add to DOM yet). */
    function createTermEntry(name) {
        var container = document.createElement('div');
        container.className = 'inline-terminal-container';
        container.style.width = '100%';
        container.style.height = '100%';

        var term = new Terminal({
            cursorBlink: true,
            scrollback: 5000,
            fontSize: 14,
            fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
            theme: {
                background: '#2A1B0E',
                foreground: '#E6D2B5',
                cursor: '#D8A03D',
                selectionBackground: 'rgba(216,160,61,0.3)',
                black: '#2A1B0E',
                red: '#D15D4C',
                green: '#8CB369',
                yellow: '#D8A03D',
                blue: '#A88FD9',
                magenta: '#A88FD9',
                cyan: '#7EC8C8',
                white: '#E6D2B5',
            }
        });

        var fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        if (typeof ClipboardAddon !== 'undefined' && ClipboardAddon.ClipboardAddon) {
            term.loadAddon(new ClipboardAddon.ClipboardAddon(undefined, new ClipboardAddon.BrowserClipboardProvider()));
        }
        term.open(container);

        // Drag-and-drop
        container.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            container.style.outline = '2px solid var(--honey)';
        });
        container.addEventListener('dragleave', function() {
            container.style.outline = '';
        });
        container.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            container.style.outline = '';
            if (e.dataTransfer.files.length > 0) {
                uploadAndPaste(e.dataTransfer.files[0]);
            }
        });

        // Block Ctrl+V raw 0x16
        term.attachCustomKeyEventHandler(function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'v' && e.type === 'keydown') {
                return false;
            }
            if (e.ctrlKey && e.type === 'keydown') {
                if (e.key === ']' || e.key === '[') {
                    e.preventDefault();
                    cycleWorker(e.key === ']' ? 1 : -1);
                    return false;
                }
                if (e.key === 'Tab') {
                    e.preventDefault();
                    cycleWorker(e.shiftKey ? -1 : 1);
                    return false;
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'c' && e.type === 'keydown') {
                var sel = term.getSelection();
                if (sel) {
                    navigator.clipboard.writeText(sel).then(function() {
                        showToast('Copied to clipboard');
                    });
                    term.clearSelection();
                    return false;
                }
            }
            return true;
        });

        // Paste handler
        if (term.textarea) {
            term.textarea.addEventListener('paste', function(e) {
                var cd = e.clipboardData || window.clipboardData || {};
                var text = cd.getData('text');
                if (text) {
                    e.preventDefault();
                    e.stopPropagation();
                    term.paste(text);
                    return;
                }
                var items = cd.items || [];
                for (var i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        e.preventDefault();
                        e.stopPropagation();
                        var blob = items[i].getAsFile();
                        if (blob) uploadAndPaste(blob);
                        return;
                    }
                }
            }, true);
        }

        var entry = {
            term: term,
            fitAddon: fitAddon,
            ws: null,
            container: container,
            connectTimer: null,
            reconnectAttempts: 0,
            reconnectTimer: null,
            lastCols: 0,
            lastRows: 0,
            lastAccess: Date.now()
        };
        return entry;
    }

    /** Connect (or reconnect) a cache entry's WebSocket. */
    function connectTermEntryWs(name, entry) {
        var path = '/ws/terminal?worker=' + encodeURIComponent(name);
        var newWs = new WebSocket(wsUrl(path));
        newWs.binaryType = 'arraybuffer';
        entry.ws = newWs;
        if (activeTermWorker === name) inlineTermWs = newWs;
        console.log('[swarm-term] WS connecting:', path);

        newWs.onopen = function() {
            console.log('[swarm-term] WS open for', name);
            entry.reconnectAttempts = 0;
            sendResizeIfChanged(name, entry);
            // Sync scrollbar after initial snapshot renders
            setTimeout(function() { entry.term.scrollToBottom(); }, 50);
            if (activeTermWorker === name && !window.matchMedia('(pointer: coarse)').matches) {
                entry.term.focus();
            }
        };

        newWs.onmessage = function(e) {
            if (e.data instanceof ArrayBuffer && entry.ws === newWs) {
                entry.term.write(new Uint8Array(e.data));
            }
        };

        newWs.onclose = function(ev) {
            console.log('[swarm-term] WS close for ' + name + ': code=' + ev.code + ' stale=' + (entry.ws !== newWs));
            if (entry.ws !== newWs) return;
            entry.ws = null;
            if (activeTermWorker === name) inlineTermWs = null;
            // Reconnect if entry still exists
            if (termCache.has(name) && entry.reconnectAttempts < MAX_TERM_RECONNECT) {
                entry.reconnectAttempts++;
                var delay = 500 * entry.reconnectAttempts;
                console.log('[swarm-term] reconnect ' + name + ' attempt ' + entry.reconnectAttempts + '/' + MAX_TERM_RECONNECT + ' in ' + delay + 'ms');
                entry.reconnectTimer = setTimeout(function() {
                    entry.reconnectTimer = null;
                    if (termCache.has(name)) {
                        entry.term.reset();  // Clean slate before reconnect snapshot
                        connectTermEntryWs(name, entry);
                    }
                }, delay);
            } else if (activeTermWorker === name) {
                // All reconnects exhausted for the active terminal — show static
                destroyTermEntry(name);
                refreshDetailStatic();
                showToast('Terminal disconnected — showing static capture', true);
            }
        };

        newWs.onerror = function(ev) {
            console.error('[swarm-term] WS error for', name, ev);
        };

        // Terminal input → WS (idempotent: xterm.js replaces previous onData)
        entry.term.onData(function(data) {
            if (entry.ws && entry.ws.readyState === WebSocket.OPEN) {
                var encoder = new TextEncoder();
                entry.ws.send(encoder.encode(data));
            }
        });
    }

    /** Send resize only when dimensions actually changed. */
    function sendResizeIfChanged(name, entry) {
        if (!entry.fitAddon || !entry.term) return;
        var dims = entry.fitAddon.proposeDimensions();
        if (!dims) return;
        if (dims.cols === entry.lastCols && dims.rows === entry.lastRows) return;
        entry.lastCols = dims.cols;
        entry.lastRows = dims.rows;
        if (entry.ws && entry.ws.readyState === WebSocket.OPEN) {
            entry.ws.send(JSON.stringify({ cols: dims.cols, rows: dims.rows }));
        }
    }

    /** Show a cached entry in the detail panel. */
    function showTermEntry(name, entry) {
        var body = document.getElementById('detail-body');
        body.innerHTML = '';
        body.style.padding = '0';
        body.style.overflow = 'hidden';
        body.appendChild(entry.container);
        entry.lastAccess = Date.now();
        activeTermWorker = name;
        syncTermAliases(entry);

        // Fit after layout settles
        requestAnimationFrame(function() {
            if (activeTermWorker !== name) return;
            entry.fitAddon.fit();
            sendResizeIfChanged(name, entry);
            if (!window.matchMedia('(pointer: coarse)').matches) {
                entry.term.focus();
            }
        });

        // Reconnect WS if dead
        if (!entry.ws || entry.ws.readyState !== WebSocket.OPEN) {
            entry.term.reset();  // Clean slate for fresh snapshot
            entry.reconnectAttempts = 0;
            connectTermEntryWs(name, entry);
        }
    }

    /** Hide the active terminal (non-destructive — keeps Terminal + WS alive). */
    function hideActiveTermEntry() {
        if (!activeTermWorker) return;
        var entry = termCache.get(activeTermWorker);
        if (entry && entry.container.parentNode) {
            entry.container.remove();  // detach from DOM, keep in memory
        }
        activeTermWorker = null;
        syncTermAliases(null);
        var body = document.getElementById('detail-body');
        if (body) {
            body.style.padding = '';
            body.style.overflow = '';
        }
    }

    /** Fully destroy a cache entry (close WS, dispose Terminal, remove from cache). */
    function destroyTermEntry(name) {
        var entry = termCache.get(name);
        if (!entry) return;
        console.log('[swarm-term] destroyTermEntry:', name);
        if (entry.connectTimer) { clearTimeout(entry.connectTimer); entry.connectTimer = null; }
        if (entry.reconnectTimer) { clearTimeout(entry.reconnectTimer); entry.reconnectTimer = null; }
        if (entry.ws) { try { entry.ws.close(); } catch(e) {} entry.ws = null; }
        if (entry.term) { try { entry.term.dispose(); } catch(e) {} }
        if (entry.container && entry.container.parentNode) entry.container.remove();
        termCache.delete(name);
        if (activeTermWorker === name) {
            activeTermWorker = null;
            syncTermAliases(null);
        }
    }

    /** LRU eviction when cache exceeds MAX_CACHED_TERMS. */
    function evictIfNeeded() {
        while (termCache.size >= MAX_CACHED_TERMS) {
            // Find least recently accessed entry (skip the active one)
            var oldest = null;
            var oldestName = null;
            termCache.forEach(function(entry, name) {
                if (name === activeTermWorker) return;
                if (!oldest || entry.lastAccess < oldest.lastAccess) {
                    oldest = entry;
                    oldestName = name;
                }
            });
            if (oldestName) {
                console.log('[swarm-term] evicting cached terminal:', oldestName);
                destroyTermEntry(oldestName);
            } else {
                break;  // only the active entry remains — can't evict
            }
        }
    }

    /** Prune cache entries for workers that no longer exist. */
    function pruneStaleTermEntries(workerNames) {
        var stale = [];
        termCache.forEach(function(_entry, name) {
            if (!workerNames.has(name)) stale.push(name);
        });
        stale.forEach(function(name) {
            console.log('[swarm-term] pruning stale terminal:', name);
            destroyTermEntry(name);
        });
    }

    function attachInlineTerminal(workerName) {
        // Already showing this worker
        if (activeTermWorker === workerName) return;

        // Fall back to static if xterm CDN hasn't loaded yet
        if (typeof Terminal === 'undefined') {
            refreshDetailStatic();
            return;
        }

        console.log('[swarm-term] attachInlineTerminal:', workerName);

        // Hide current terminal (non-destructive)
        hideActiveTermEntry();

        // Cache hit — re-show the existing terminal
        var entry = termCache.get(workerName);
        if (entry) {
            showTermEntry(workerName, entry);
            return;
        }

        // Cache miss — create, cache, show
        evictIfNeeded();
        entry = createTermEntry(workerName);
        termCache.set(workerName, entry);

        // Add to DOM and show
        var body = document.getElementById('detail-body');
        body.innerHTML = '';
        body.style.padding = '0';
        body.style.overflow = 'hidden';
        body.appendChild(entry.container);
        activeTermWorker = workerName;
        syncTermAliases(entry);
        entry.lastAccess = Date.now();

        // Fit + connect after layout
        entry.connectTimer = setTimeout(function() {
            entry.connectTimer = null;
            if (activeTermWorker !== workerName) return;
            entry.fitAddon.fit();
            connectTermEntryWs(workerName, entry);
            if (!window.matchMedia('(pointer: coarse)').matches) {
                entry.term.focus();
            }
        }, 50);
    }

    function uploadAndPaste(file) {
        if (!inlineTerm || !inlineTermWs || inlineTermWs.readyState !== WebSocket.OPEN) {
            showToast('Terminal not connected', true);
            return;
        }
        var fname = file.name || ('paste-' + Date.now() + '.png');
        showToast('Uploading ' + fname + '...');
        var fd = new FormData();
        fd.append('file', file, fname);
        fetch('/api/uploads', { method: 'POST', body: fd, headers: { 'X-Requested-With': 'swarm' } })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.path && inlineTerm) {
                    inlineTerm.paste(data.path);
                    showToast('Pasted: ' + fname);
                } else if (!data.path) {
                    showToast('Upload failed: ' + (data.error || 'unknown'), true);
                }
            })
            .catch(function() { showToast('Upload failed', true); });
    }

    function detachInlineTerminal() {
        console.log('[swarm-term] detachInlineTerminal (hide, non-destructive)');
        hideActiveTermEntry();
    }

    window.refreshInlineTerminal = function() {
        if (activeTermWorker) {
            var worker = activeTermWorker;
            destroyTermEntry(worker);
            attachInlineTerminal(worker);
        } else {
            refreshDetailStatic();
        }
    }

    // --- Worker selection (client-side, no page reload) ---
    window.selectWorker = function(name) {
        selectedWorker = name;
        try { sessionStorage.setItem('swarm_selected_worker', name); } catch(e) {}
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({command: "focus", worker: name}));
        }
        var taskText = '';
        document.querySelectorAll('.worker-item').forEach(function(el) {
            el.classList.toggle('selected', el.dataset.worker === name);
            if (el.dataset.worker === name) {
                var taskEl = el.querySelector('.worker-task');
                if (taskEl) taskText = taskEl.textContent.trim();
            }
        });
        document.getElementById('detail-title').textContent = name + (taskText ? ' — ' + taskText : ' — Detail');
        document.getElementById('terminal-actions').style.display = 'flex';
        // Show mobile-only controls on touch devices
        var sendBar = document.getElementById('mobile-send-bar');
        if (sendBar) sendBar.classList.add('visible');
        var fsBtn = document.getElementById('btn-fullscreen-term');
        if (fsBtn && window.matchMedia('(pointer: coarse)').matches) {
            fsBtn.style.display = '';
        }
        attachInlineTerminal(name);
    }

    // Mobile send bar — type/dictate text and send to worker terminal
    window.mobileSend = function() {
        var input = document.getElementById('mobile-send-input');
        if (!input || !input.value) return;
        var text = input.value;
        input.value = '';
        if (inlineTermWs && inlineTermWs.readyState === WebSocket.OPEN) {
            var encoder = new TextEncoder();
            inlineTermWs.send(encoder.encode(text + '\r'));
        } else if (selectedWorker) {
            var form = new FormData();
            form.append('message', text);
            fetch('/action/send/' + encodeURIComponent(selectedWorker), { method: 'POST', body: form });
        }
    }

    // --- Fullscreen terminal (mobile scroll mode) ---
    // Moves the existing inline terminal into a fixed overlay so
    // one-finger swipe scrolls terminal history.  No new WebSocket is
    // opened — we reuse the existing connection.
    window.openTerminalFullscreen = function() {
        if (!activeTermWorker) return;
        var entry = termCache.get(activeTermWorker);
        if (!entry || !entry.term || !entry.ws || !entry.fitAddon) return;
        if (entry.ws.readyState !== WebSocket.OPEN) return;

        var termEl = entry.container;
        if (!termEl) return;
        var origParent = termEl.parentNode;

        var overlay = document.createElement('div');
        overlay.className = 'terminal-fullscreen';
        overlay.id = 'terminal-fullscreen-overlay';
        overlay.innerHTML =
            '<div class="terminal-fullscreen-bar">' +
            '  <span class="fs-title">' + (selectedWorker || 'Terminal') + '</span>' +
            '  <button class="btn-close-fs" id="btn-close-fs">Close</button>' +
            '</div>' +
            '<div class="terminal-fullscreen-body" id="fs-term-body"></div>';
        document.body.appendChild(overlay);

        document.getElementById('fs-term-body').appendChild(termEl);

        function fitAndResize() {
            if (!entry.fitAddon || !entry.term) return;
            entry.fitAddon.fit();
            sendResizeIfChanged(activeTermWorker, entry);
        }

        requestAnimationFrame(function() {
            setTimeout(fitAndResize, 80);
        });

        var vpResize = function() { fitAndResize(); };
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', vpResize);
        }

        var body = document.getElementById('fs-term-body');
        var touchStartY = null;
        var accum = 0;
        var LINE_PX = 15;

        body.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                touchStartY = e.touches[0].clientY;
                accum = 0;
            }
        }, { passive: true });

        body.addEventListener('touchmove', function(e) {
            if (touchStartY === null) return;
            if (!entry.ws || entry.ws.readyState !== WebSocket.OPEN) return;
            var dy = e.touches[0].clientY - touchStartY;
            accum += dy;
            var lines = Math.trunc(accum / LINE_PX);
            if (lines !== 0) {
                entry.ws.send(JSON.stringify({ action: 'scroll', lines: lines }));
                accum -= lines * LINE_PX;
            }
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        body.addEventListener('touchend', function() {
            touchStartY = null;
        }, { passive: true });

        document.getElementById('btn-close-fs').addEventListener('click', function() {
            if (window.visualViewport) {
                window.visualViewport.removeEventListener('resize', vpResize);
            }
            origParent.appendChild(termEl);
            overlay.remove();
            requestAnimationFrame(function() {
                setTimeout(fitAndResize, 80);
            });
        });
    }

    // --- Tab switcher ---
    window.switchTab = function(tab) {
        document.querySelectorAll('.tab-btn').forEach(function(b) { b.classList.remove('active'); });
        document.querySelectorAll('.tab-content').forEach(function(c) { c.classList.remove('active'); });
        document.getElementById('tab-' + tab + '-btn').classList.add('active');
        document.getElementById('tab-' + tab).classList.add('active');
        if (tab === 'tasks') {
            var tl = document.getElementById('task-list');
            if (tl) setTimeout(function() { tl.scrollTop = tl.scrollHeight; }, 0);
        } else if (tab === 'decisions') {
            refreshProposals();
            refreshDecisions();
        } else if (tab === 'buzz') {
            unreadNotifications = 0;
            var badge = document.getElementById('notif-badge');
            if (badge) badge.style.display = 'none';
            updateAppBadge(0);
            refreshBuzzLog();
        }
    }

    // --- Mobile overflow menu ---
    window.toggleMobileMenu = function(e) {
        e.stopPropagation();
        var menu = document.getElementById('mobile-overflow-menu');
        menu.classList.toggle('open');
    };
    window.closeMobileMenu = function() {
        var menu = document.getElementById('mobile-overflow-menu');
        if (menu) menu.classList.remove('open');
    };
    document.addEventListener('click', function() { closeMobileMenu(); });

    // --- Actions ---
    window.toggleDrones = function() {
        fetch('/action/toggle-drones', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                updateDronesButton(data.enabled);
                refreshStatus();
            });
    }

    function updateDronesButton(enabled) {
        const btn = document.getElementById('drones-btn');
        btn.textContent = 'Drones: ' + (enabled ? 'ON' : 'OFF');
        btn.className = 'btn ' + (enabled ? 'btn-active' : 'btn-secondary');
    }

    // --- Tunnel ---
    var tunnelUrl = {{ tunnel.url | tojson }};
    var tunnelActionPending = false; // suppress duplicate WS toasts during user-initiated actions

    function updateTunnelButton(running, url) {
        tunnelUrl = url || '';
        const btn = document.getElementById('tunnel-btn');
        btn.textContent = running ? 'Tunnel: ON' : 'Tunnel';
        btn.className = 'btn ' + (running ? 'btn-active' : 'btn-secondary');
    }

    window.tunnelAction = function() {
        if (tunnelUrl) {
            showTunnelModal(tunnelUrl);
        } else {
            const btn = document.getElementById('tunnel-btn');
            btn.textContent = 'Starting...';
            btn.disabled = true;
            tunnelActionPending = true;
            fetch('/action/tunnel/start', { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    btn.disabled = false;
                    tunnelActionPending = false;
                    if (data.error) {
                        showToast('Tunnel error: ' + data.error, true);
                        updateTunnelButton(false, '');
                    } else {
                        tunnelUrl = data.url;
                        updateTunnelButton(true, data.url);
                        showTunnelModal(data.url);
                        if (data.warning) showToast(data.warning, true);
                    }
                })
                .catch(function() {
                    btn.disabled = false;
                    tunnelActionPending = false;
                    updateTunnelButton(false, '');
                    showToast('Failed to start tunnel', true);
                });
        }
    }

    function showTunnelModal(url) {
        document.getElementById('tunnel-url-text').textContent = url;
        document.getElementById('tunnel-modal').style.display = 'flex';
        // Generate QR code
        var container = document.getElementById('tunnel-qr');
        container.innerHTML = '';
        if (typeof QRCode !== 'undefined') {
            try {
                new QRCode(container, {
                    text: url,
                    width: 220,
                    height: 220,
                    colorDark: '#E6D2B5',
                    colorLight: '#2A1B0E',
                    correctLevel: QRCode.CorrectLevel.M
                });
            } catch(e) {
                console.error('QR generation failed:', e);
            }
        }
    }

    window.hideTunnel = function() {
        document.getElementById('tunnel-modal').style.display = 'none';
    }

    window.copyTunnelUrl = function() {
        if (tunnelUrl && navigator.clipboard) {
            navigator.clipboard.writeText(tunnelUrl);
            showToast('URL copied');
        }
    }

    window.stopTunnel = function() {
        hideTunnel();
        tunnelActionPending = true;
        fetch('/action/tunnel/stop', { method: 'POST' })
            .then(r => r.json())
            .then(function() {
                tunnelActionPending = false;
                updateTunnelButton(false, '');
                showToast('Tunnel stopped');
            });
    }

    window.continueAll = function() {
        fetch('/action/continue-all', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                showToast('Continued ' + data.count + ' worker(s)');
                setTimeout(refreshWorkers, 1000);
            });
    }

    window.doAction = function(action, command) {
        if (action === 'revive') { reviveWorker(); return; }
        if (action === 'refresh') { refreshInlineTerminal(); return; }
        if (action === 'queen') { askQueenWorker(); return; }
        if (action === 'kill') { killWorker(); return; }
        // Custom button: send command or continue
        if (command) { sendToolCommand(command); } else { continueWorker(); }
    }

    window.sendToolCommand = function(command) {
        if (!selectedWorker) return;
        var form = new FormData();
        form.append('message', command);
        fetch('/action/send/' + selectedWorker, { method: 'POST', body: form })
            .then(function() {
                showToast('Sent "' + command + '" to ' + selectedWorker);
            });
    }

    window.continueWorker = function() {
        if (!selectedWorker) return;
        fetch('/action/continue/' + encodeURIComponent(selectedWorker), { method: 'POST' })
            .then(function() {
                showToast('Continued ' + selectedWorker);
                setTimeout(refreshWorkers, 1000);
            });
    }

    window.reviveWorker = function() {
        if (!selectedWorker) return;
        fetch('/action/revive/' + selectedWorker, { method: 'POST' })
            .then(r => r.json())
            .then(function() {
                showToast('Reviving ' + selectedWorker);
                setTimeout(refreshDetail, 2000);
            });
    }

    window.killWorker = function() {
        if (!selectedWorker) return;
        showConfirm('Kill worker "' + selectedWorker + '"? This will terminate the process.', function() {
            destroyTermEntry(selectedWorker);
            fetch('/action/kill/' + selectedWorker, { method: 'POST' })
                .then(r => r.json())
                .then(function() {
                    showToast('Killed ' + selectedWorker, true);
                    selectedWorker = null;
                    document.getElementById('detail-title').textContent = 'Select a worker';
                    document.getElementById('detail-body').innerHTML = '<p class="placeholder-text">Click a worker to see details</p>';
                    document.getElementById('terminal-actions').style.display = 'none';
                    refreshWorkers();
                });
        });
    }

    // --- Unified Task Modal (create + edit) ---
    let taskModalMode = null; // 'create' or 'edit'
    let taskModalId = null;   // task ID when editing
    let taskModalPendingFiles = []; // files queued during create mode
    let taskModalAttachmentPaths = []; // pre-saved attachment paths (e.g. from email)
    let taskModalSourceEmailId = ''; // Graph message ID for email-sourced tasks

    window.showCreateTask = function() {
        openTaskModal('create');
    };

    window.handleEmailDrop = function(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        var dt = event.dataTransfer;
        var files = dt && dt.files;
        var items = dt && dt.items;

        // Debug: log what Outlook provides
        var types = dt ? [].slice.call(dt.types) : [];
        console.log('[email-drop] types:', types, 'files:', files ? files.length : 0, 'items:', items ? items.length : 0);
        if (files) { for (var d = 0; d < files.length; d++) console.log('[email-drop] file:', files[d].name, files[d].type, files[d].size); }

        // 1. Look for .eml or .msg files (also check items API)
        var emailFile = null;
        if (files && files.length > 0) {
            for (var i = 0; i < files.length; i++) {
                var name = files[i].name.toLowerCase();
                if (name.endsWith('.eml') || name.endsWith('.msg')) { emailFile = files[i]; break; }
            }
        }
        if (!emailFile && items && items.length > 0) {
            for (var ii = 0; ii < items.length; ii++) {
                if (items[ii].kind === 'file') {
                    var f = items[ii].getAsFile();
                    if (f) {
                        var fn = f.name.toLowerCase();
                        if (fn.endsWith('.eml') || fn.endsWith('.msg') || f.type === 'application/vnd.ms-outlook') {
                            emailFile = f; break;
                        }
                    }
                }
            }
        }

        if (emailFile) {
            showToast('Parsing email: ' + emailFile.name);
            var fd = new FormData();
            fd.append('file', emailFile);
            fetch('/api/tasks/from-email', { method: 'POST', body: fd, headers: { 'X-Requested-With': 'fetch' } })
                .then(function(r) {
                    if (!r.ok) return r.text().then(function(t) { throw new Error(t); });
                    return r.json();
                })
                .then(function(data) {
                    if (data.error) { showToast('Email parse failed: ' + data.error, true); return; }
                    openTaskModal('create', { title: data.title || '', desc: data.description || '', task_type: data.task_type || '' });
                    taskModalAttachmentPaths = data.attachments || [];
                    taskModalSourceEmailId = data.message_id || '';
                    for (var j = 0; j < taskModalAttachmentPaths.length; j++) {
                        addThumbnail(taskModalAttachmentPaths[j]);
                    }
                    // Client-side auto-classify fallback
                    if (!data.task_type) {
                        var detected = autoClassifyType((data.title || '') + ' ' + (data.description || ''));
                        if (detected) document.getElementById('tm-task-type').value = detected;
                    }
                })
                .catch(function(err) { showToast('Email parse error: ' + err, true); });
            return;
        }

        // 2. No email file — try text/html or text/plain (Outlook sometimes provides this)
        var html = dt && dt.getData('text/html');
        var text = dt && dt.getData('text/plain');
        var content = html || text || '';
        if (content.trim()) {
            var desc = content.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
            openTaskModal('create', { title: '', desc: desc });
            showToast('Email content captured — review and create');
            return;
        }

        // 3. New Outlook drag — extract subject + message ID, fetch via Graph if configured
        if (types.indexOf('multimaillistmessagerows') !== -1) {
            var rowData = dt.getData('multimaillistmessagerows');
            console.log('[email-drop] multimaillistmessagerows data:', rowData);
            var outlookData = null;
            try { outlookData = JSON.parse(rowData); } catch (pe) { /* not JSON */ }
            if (outlookData) {
                var subj = (outlookData.subjects && outlookData.subjects[0]) || '';
                var msgId = (outlookData.latestItemIds && outlookData.latestItemIds[0]) || '';
                var userEmail = '';
                if (outlookData.mailboxInfos && outlookData.mailboxInfos[0]) {
                    userEmail = outlookData.mailboxInfos[0].mailboxSmtpAddress || '';
                }
                console.log('[email-drop] subject:', subj, 'msgId:', msgId, 'user:', userEmail);

                // Try Graph API fetch if configured
                if (msgId) {
                    showToast('Fetching email via Microsoft Graph...');
                    fetch('/action/fetch-outlook-email', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: 'message_id=' + encodeURIComponent(msgId) + '&user=' + encodeURIComponent(userEmail)
                    })
                    .then(function(r) { return r.json(); })
                    .then(function(data) {
                        console.log('[email-drop] Graph response:', data);
                        if (data.error) {
                            // Graph not configured or fetch failed — fall back to subject-only + paste prompt
                            console.warn('[email-drop] Graph error:', data.error);
                            openTaskModal('create', { title: subj, desc: '' });
                            showToast('Email "' + subj + '" — paste body (Ctrl+V) and drag images to add them');
                            return;
                        }
                        openTaskModal('create', {
                            title: data.title || subj,
                            desc: data.description || '',
                            task_type: data.task_type || ''
                        });
                        taskModalAttachmentPaths = data.attachments || [];
                        taskModalSourceEmailId = data.message_id || '';
                        for (var ai = 0; ai < taskModalAttachmentPaths.length; ai++) {
                            addThumbnail(taskModalAttachmentPaths[ai]);
                        }
                        // Fallback: run client-side auto-classify if backend didn't set type
                        if (!data.task_type) {
                            var detected = autoClassifyType((data.title || subj) + ' ' + (data.description || ''));
                            if (detected) document.getElementById('tm-task-type').value = detected;
                        }
                        var imgCount = taskModalAttachmentPaths.length;
                        showToast('Email imported' + (imgCount > 0 ? ' with ' + imgCount + ' attachment(s)' : ''));
                    })
                    .catch(function() {
                        openTaskModal('create', { title: subj, desc: '' });
                        showToast('Email "' + subj + '" — paste body (Ctrl+V) and drag images to add them');
                    });
                    return;
                }

                // No message ID — just use subject
                openTaskModal('create', { title: subj, desc: '' });
                showToast('Email "' + subj + '" — paste body (Ctrl+V) and drag images to add them');
                return;
            }
            showToast('New Outlook drag detected — paste the email (Ctrl+V) instead', true);
            return;
        }

        // 4. Files present but not email — attach them
        if (files && files.length > 0) {
            openTaskModal('create');
            for (var k = 0; k < files.length; k++) {
                handleTaskFile(files[k]);
            }
            showToast(files.length + ' file(s) added as attachments');
            return;
        }

        showToast('No email data found in drop. Copy the email (Ctrl+C) and paste here (Ctrl+V) instead.', true);
    };

    window.showEditTask = function(taskId, title, desc, priority, taskType, tags, deps, resolution, status) {
        openTaskModal('edit', { id: taskId, title: title, desc: desc, priority: priority, task_type: taskType, tags: tags, deps: deps, resolution: resolution || '', status: status || '' });
    };

    function openTaskModal(mode, data) {
        taskModalMode = mode;
        taskModalId = (data && data.id) || null;
        taskModalPendingFiles = [];
        taskModalAttachmentPaths = [];
        taskModalSourceEmailId = '';

        document.getElementById('tm-title').value = (data && data.title) || '';
        document.getElementById('tm-desc').value = (data && data.desc) || '';
        document.getElementById('tm-priority').value = (data && data.priority) || 'normal';
        document.getElementById('tm-task-type').value = (data && data.task_type) || '';
        document.getElementById('tm-tags').value = (data && data.tags) || '';
        document.getElementById('tm-deps').value = (data && data.deps) || '';
        document.getElementById('tm-attachments').innerHTML = '';

        var header = document.getElementById('task-modal-header');
        var titleEl = document.getElementById('task-modal-title');
        var submitBtn = document.getElementById('tm-submit-btn');
        var descEl = document.getElementById('tm-desc');
        var titleHint = document.getElementById('tm-title-hint');

        // Tags row only visible in edit mode
        document.getElementById('tm-tags-row').style.display = (mode === 'edit') ? '' : 'none';

        // Resolution display (read-only, completed tasks only)
        var resolutionRow = document.getElementById('tm-resolution-row');
        var resolutionEl = document.getElementById('tm-resolution');
        if (mode === 'edit' && data && data.resolution && data.status === 'completed') {
            resolutionRow.style.display = 'block';
            resolutionEl.textContent = data.resolution;
        } else {
            resolutionRow.style.display = 'none';
            resolutionEl.textContent = '';
        }

        submitBtn.disabled = false;
        if (mode === 'create') {
            titleEl.textContent = 'New Task';
            submitBtn.textContent = 'Create';
            header.style.background = 'var(--lavender)';
            descEl.rows = 24;
            if (titleHint) titleHint.style.display = '';
        } else {
            titleEl.textContent = 'Edit Task';
            submitBtn.textContent = 'Save';
            header.style.background = 'var(--panel)';
            descEl.rows = 4;
            if (titleHint) titleHint.style.display = 'none';
        }

        document.getElementById('task-modal').style.display = 'flex';
        if (mode === 'create') {
            descEl.focus();
        } else {
            document.getElementById('tm-title').focus();
        }
    }

    // Client-side auto-classify: mirrors Python keyword logic
    function autoClassifyType(text) {
        text = text.toLowerCase();
        var bugKw = ['bug','fix','broken','crash','error','fail','issue','defect','regression','wrong','incorrect','not working'];
        var verifyKw = ['verify','check','confirm','test','validate','qa','review','ensure','audit','inspect'];
        var featureKw = ['add','new','feature','implement','create','build','introduce','support','enable','extend'];
        var bugScore = 0, verifyScore = 0, featureScore = 0;
        bugKw.forEach(function(kw) { if (text.indexOf(kw) !== -1) bugScore++; });
        verifyKw.forEach(function(kw) { if (text.indexOf(kw) !== -1) verifyScore++; });
        featureKw.forEach(function(kw) { if (text.indexOf(kw) !== -1) featureScore++; });
        var best = Math.max(bugScore, verifyScore, featureScore);
        if (best === 0) return '';
        var scores = [bugScore, verifyScore, featureScore];
        if (scores.filter(function(s) { return s === best; }).length > 1) return '';
        if (bugScore === best) return 'bug';
        if (verifyScore === best) return 'verify';
        return 'feature';
    }

    // Auto-detect type on description blur (only when type is set to Auto-detect)
    document.getElementById('tm-desc').addEventListener('blur', function() {
        var typeEl = document.getElementById('tm-task-type');
        if (typeEl.value === '' && taskModalMode === 'create') {
            var title = document.getElementById('tm-title').value;
            var desc = this.value;
            var detected = autoClassifyType(title + ' ' + desc);
            if (detected) typeEl.value = detected;
        }
    });

    window.closeTaskModal = function() {
        document.getElementById('task-modal').style.display = 'none';
        taskModalMode = null;
        taskModalId = null;
        taskModalPendingFiles = [];
        taskModalAttachmentPaths = [];
        taskModalSourceEmailId = '';
    };

    window.submitTaskModal = function() {
        var title = document.getElementById('tm-title').value.trim();
        var desc = document.getElementById('tm-desc').value;
        var priority = document.getElementById('tm-priority').value;
        var taskType = document.getElementById('tm-task-type').value;
        var tags = document.getElementById('tm-tags').value;
        var deps = document.getElementById('tm-deps').value.trim();

        if (!title && !desc.trim()) { showToast('Title or description required', true); return; }

        var submitBtn = document.getElementById('tm-submit-btn');
        var origLabel = submitBtn.textContent;
        submitBtn.disabled = true;
        submitBtn.textContent = (taskModalMode === 'edit') ? 'Saving...' : 'Creating...';

        function resetBtn() { submitBtn.disabled = false; submitBtn.textContent = origLabel; }

        if (taskModalMode === 'edit') {
            // Edit existing task
            fetch('/action/task/edit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'task_id=' + encodeURIComponent(taskModalId)
                    + '&title=' + encodeURIComponent(title)
                    + '&description=' + encodeURIComponent(desc)
                    + '&priority=' + priority
                    + '&task_type=' + taskType
                    + '&tags=' + encodeURIComponent(tags)
                    + '&depends_on=' + encodeURIComponent(deps)
            })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.status === 'updated') {
                    showToast('Task updated');
                    closeTaskModal();
                    refreshTasks();
                } else {
                    showToast('Error: ' + (data.error || 'unknown'), true);
                    resetBtn();
                }
            })
            .catch(function(err) { showToast('Error: ' + err, true); resetBtn(); });
        } else {
            // Create new task, then upload any pending files
            if (!title) showToast('Generating title via AI...');
            var createBody = 'title=' + encodeURIComponent(title)
                    + '&description=' + encodeURIComponent(desc)
                    + '&priority=' + priority
                    + '&task_type=' + taskType
                    + '&depends_on=' + encodeURIComponent(deps);
            if (taskModalAttachmentPaths.length > 0) {
                createBody += '&attachments=' + encodeURIComponent(taskModalAttachmentPaths.join(','));
            }
            if (taskModalSourceEmailId) {
                createBody += '&source_email_id=' + encodeURIComponent(taskModalSourceEmailId);
            }
            fetch('/action/task/create', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: createBody
            })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.id) {
                    showToast('Task created: ' + data.title);
                    // Upload any pending files
                    var uploads = taskModalPendingFiles.map(function(file) {
                        var fd = new FormData();
                        fd.append('task_id', data.id);
                        fd.append('file', file);
                        return fetch('/action/task/upload', { method: 'POST', body: fd });
                    });
                    Promise.all(uploads).then(function() {
                        if (uploads.length > 0) showToast(uploads.length + ' attachment(s) uploaded');
                        refreshTasks();
                    });
                    closeTaskModal();
                } else {
                    showToast('Error: ' + (data.error || 'unknown'), true);
                    resetBtn();
                }
            })
            .catch(function(err) { showToast('Error: ' + err, true); resetBtn(); });
        }
    };

    window.assignTask = function(taskId, taskTitle) {
        if (!selectedWorker) {
            showToast('Select a worker first', true);
            return;
        }
        postAction(
            '/action/task/assign',
            'task_id=' + encodeURIComponent(taskId) + '&worker=' + encodeURIComponent(selectedWorker),
            function(data) {
                if (data.status === 'assigned') {
                    showToast('Assigned "' + taskTitle + '" to ' + selectedWorker);
                    refreshTasks();
                }
            }
        );
    }

    window.completeTask = function(taskId) {
        taskAction('complete', taskId, 'completed', 'Task completed');
    }

    window.removeTask = function(taskId) {
        showConfirm('Remove this task?', function() {
            taskAction('remove', taskId, 'removed', 'Task removed');
        });
    }

    window.failTask = function(taskId) {
        taskAction('fail', taskId, 'failed', 'Task failed');
    }

    window.unassignTask = function(taskId) {
        taskAction('unassign', taskId, 'unassigned', 'Task unassigned');
    }

    window.reopenTask = function(taskId) {
        taskAction('reopen', taskId, 'reopened', 'Task reopened');
    }

    window.retryDraft = function(taskId) {
        showToast('Retrying draft reply...');
        postAction(
            '/action/task/retry-draft',
            'task_id=' + encodeURIComponent(taskId),
            function() {}
        );
    }

    // --- Broadcast ---
    window.showBroadcast = function() {
        document.getElementById('broadcast-modal').style.display = 'flex';
        document.getElementById('broadcast-input').focus();
    }

    window.hideBroadcast = function() {
        document.getElementById('broadcast-modal').style.display = 'none';
        document.getElementById('broadcast-input').value = '';
    }

    window.sendBroadcast = function() {
        const msg = document.getElementById('broadcast-input').value.trim();
        if (!msg) return;
        const target = document.getElementById('broadcast-target').value;

        if (target.startsWith('group:')) {
            const group = target.substring(6);
            fetch('/action/send-group', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'message=' + encodeURIComponent(msg) + '&group=' + encodeURIComponent(group)
            })
            .then(r => r.json())
            .then(data => {
                showToast('Sent to ' + data.count + ' worker(s) in ' + group);
                hideBroadcast();
            });
        } else {
            fetch('/action/send-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'message=' + encodeURIComponent(msg)
            })
            .then(r => r.json())
            .then(data => {
                showToast('Sent to ' + data.count + ' worker(s)');
                hideBroadcast();
            });
        }
    }

    // --- Queen ---
    let lastDirectives = [];

    window.askQueen = function() {
        const modal = document.getElementById('queen-modal');
        const result = document.getElementById('queen-result');
        modal.style.display = 'flex';
        document.querySelector('.queen-ask-footer').style.display = '';
        result.innerHTML = '<p class="text-muted"><img src="' + BEE.queen + '" class="bee-icon bee-md" alt="" style="margin-right:0.4rem"><span class="spinner"></span>Analyzing hive... (this may take a moment)</p>';
        document.getElementById('queen-btn').disabled = true;
        document.getElementById('queen-refresh-btn').disabled = true;
        document.getElementById('queen-apply-btn').style.display = 'none';
        lastDirectives = [];

        fetch('/action/ask-queen', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                document.getElementById('queen-btn').disabled = false;
                document.getElementById('queen-refresh-btn').disabled = false;
                startQueenCooldown(data.cooldown || 0);
                if (data.error) {
                    result.innerHTML = '<p class="text-poppy">' + escapeHtml(data.error) + '</p>';
                    return;
                }
                lastDirectives = data.directives || [];
                result.innerHTML = renderQueenResult(data);
                if (lastDirectives.some(function(d) { return d.action && d.action !== 'wait'; })) {
                    document.getElementById('queen-apply-btn').style.display = 'inline-block';
                }
            })
            .catch(err => {
                document.getElementById('queen-btn').disabled = false;
                document.getElementById('queen-refresh-btn').disabled = false;
                result.innerHTML = '<p class="text-poppy">Request failed</p>';
            });
    }

    window.hideQueen = function() {
        clearTimeout(queenAutoHideTimer);
        document.getElementById('queen-modal').style.display = 'none';
    }

    window.askQueenWorker = function() {
        if (!selectedWorker) { showToast('Select a worker first', true); return; }
        const modal = document.getElementById('queen-modal');
        const result = document.getElementById('queen-result');
        modal.style.display = 'flex';
        document.querySelector('.queen-ask-footer').style.display = '';
        result.innerHTML = '<p class="text-muted"><img src="' + BEE.queen + '" class="bee-icon bee-md" alt="" style="margin-right:0.4rem"><span class="spinner"></span>Analyzing ' + escapeHtml(selectedWorker) + '... (this may take a moment)</p>';
        document.getElementById('queen-btn').disabled = true;
        document.getElementById('queen-refresh-btn').disabled = true;
        document.getElementById('queen-apply-btn').style.display = 'none';
        lastDirectives = [];

        fetch('/action/ask-queen/' + encodeURIComponent(selectedWorker), { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                document.getElementById('queen-btn').disabled = false;
                document.getElementById('queen-refresh-btn').disabled = false;
                startQueenCooldown(data.cooldown || 0);
                if (data.error) {
                    result.innerHTML = '<p class="text-poppy">' + escapeHtml(data.error) + '</p>';
                    return;
                }
                // Per-worker analysis has assessment/reasoning/action, wrap as directives
                if (data.action && !data.directives) {
                    lastDirectives = [{ worker: selectedWorker, action: data.action, message: data.message || '', reason: data.reasoning || '' }];
                } else {
                    lastDirectives = data.directives || [];
                }
                result.innerHTML = renderQueenResult(data);
                if (lastDirectives.some(function(d) { return d.action && d.action !== 'wait'; })) {
                    document.getElementById('queen-apply-btn').style.display = 'inline-block';
                }
            })
            .catch(err => {
                document.getElementById('queen-btn').disabled = false;
                document.getElementById('queen-refresh-btn').disabled = false;
                result.innerHTML = '<p class="text-poppy">Request failed</p>';
            });
    }

    window.askQueenQuestion = function() {
        var input = document.getElementById('queen-question');
        var question = input.value.trim();
        if (!question) { showToast('Type a question first', true); return; }
        var modal = document.getElementById('queen-modal');
        var result = document.getElementById('queen-result');
        modal.style.display = 'flex';
        result.innerHTML = '<p class="text-muted"><img src="' + BEE.queen + '" class="bee-icon bee-md" alt="" style="margin-right:0.4rem"><span class="spinner"></span>Asking Queen... (this may take a moment)</p>';
        document.getElementById('queen-btn').disabled = true;
        document.getElementById('queen-refresh-btn').disabled = true;
        document.getElementById('queen-ask-btn').disabled = true;
        document.getElementById('queen-apply-btn').style.display = 'none';
        lastDirectives = [];

        fetch('/action/ask-queen-question', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'question=' + encodeURIComponent(question)
        })
            .then(r => r.json())
            .then(data => {
                document.getElementById('queen-btn').disabled = false;
                document.getElementById('queen-refresh-btn').disabled = false;
                document.getElementById('queen-ask-btn').disabled = false;
                startQueenCooldown(data.cooldown || 0);
                if (data.error) {
                    result.innerHTML = '<p class="text-poppy">' + escapeHtml(data.error) + '</p>';
                    return;
                }
                lastDirectives = data.directives || [];
                result.innerHTML = renderQueenResult(data);
                if (lastDirectives.some(function(d) { return d.action && d.action !== 'wait'; })) {
                    document.getElementById('queen-apply-btn').style.display = 'inline-block';
                }
                input.value = '';
            })
            .catch(err => {
                document.getElementById('queen-btn').disabled = false;
                document.getElementById('queen-refresh-btn').disabled = false;
                document.getElementById('queen-ask-btn').disabled = false;
                result.innerHTML = '<p class="text-poppy">Request failed</p>';
            });
    }

    function _execDirective(d) {
        // Returns true if an action was dispatched, false for no-ops (wait).
        if (d.action === 'send_message' && d.message) {
            fetch('/action/send/' + encodeURIComponent(d.worker), {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'message=' + encodeURIComponent(d.message)
            });
            return true;
        } else if (d.action === 'continue') {
            fetch('/action/continue/' + encodeURIComponent(d.worker), { method: 'POST' });
            return true;
        } else if (d.action === 'restart') {
            fetch('/action/revive/' + encodeURIComponent(d.worker), { method: 'POST' });
            return true;
        } else if (d.action === 'complete_task' && d.task_id) {
            var body = 'task_id=' + encodeURIComponent(d.task_id);
            if (d.resolution) body += '&resolution=' + encodeURIComponent(d.resolution);
            fetch('/action/task/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: body
            });
            return true;
        } else if (d.action === 'assign_task' && d.task_id && d.worker) {
            fetch('/action/task/assign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'task_id=' + encodeURIComponent(d.task_id) + '&worker=' + encodeURIComponent(d.worker)
            });
            return true;
        }
        return false; // wait or unrecognized
    }

    window.applyDirectives = function() {
        if (!lastDirectives.length) return;
        let applied = 0;
        let waited = 0;
        for (const d of lastDirectives) {
            if (!d.worker || !d.action) continue;
            if (d.action === 'wait') { waited++; continue; }
            if (_execDirective(d)) applied++;
        }
        var msg = applied > 0 ? 'Applied ' + applied + ' directive(s)' : '';
        if (waited > 0) msg += (msg ? ', ' : '') + waited + ' worker(s) waiting';
        showToast(msg || 'No actionable directives');
        document.getElementById('queen-apply-btn').style.display = 'none';
        // Mark all buttons done
        for (let i = 0; i < lastDirectives.length; i++) {
            var btn = document.getElementById('directive-btn-' + i);
            if (btn) { btn.textContent = 'Done'; btn.disabled = true; }
        }
        setTimeout(function() { refreshWorkers(); refreshDetail(); }, 1500);
    }

    window.applyDirective = function(idx) {
        const d = lastDirectives[idx];
        if (!d || !d.worker || !d.action) return;
        if (_execDirective(d)) {
            var labels = { send_message: 'Sent message to ', continue: 'Continued ', restart: 'Reviving ', complete_task: 'Completed task for ', assign_task: 'Assigned task to ' };
            showToast((labels[d.action] || 'Applied to ') + d.worker);
        } else if (d.action === 'wait') {
            showToast(d.worker + ' — waiting (no action needed)');
        }
        // Mark as applied visually
        const btn = document.getElementById('directive-btn-' + idx);
        if (btn) { btn.textContent = 'Done'; btn.disabled = true; }
    }

    function renderQueenResult(data) {
        let html = '';
        // Top-level analysis
        if (data.assessment) {
            html += '<div class="queen-card-assessment">';
            html += '<strong class="text-honey">Assessment</strong><br>';
            html += '<span>' + escapeHtml(data.assessment) + '</span></div>';
        }
        if (data.reasoning) {
            html += '<div class="queen-card-assessment">';
            html += '<strong class="text-honey">Reasoning</strong><br>';
            html += '<span>' + escapeHtml(data.reasoning) + '</span></div>';
        }
        // Directives with per-directive apply buttons
        const directives = data.directives || [];
        var actionLabels = { wait: 'wait', continue: 'continue', send_message: 'send msg', restart: 'restart', complete_task: 'complete task', assign_task: 'assign task' };
        var hasActionable = directives.some(function(d) { return d.action && d.action !== 'wait'; });
        if (directives.length > 0) {
            html += '<div class="mb-sm"><strong class="text-lavender">Directives (' + directives.length + ')</strong></div>';
            for (let i = 0; i < directives.length; i++) {
                const d = directives[i];
                var actionColor = d.action === 'complete_task' ? 'text-sage' : d.action === 'wait' ? 'text-muted' : 'text-honey';
                html += '<div class="directive-row">';
                html += '<span class="directive-worker">' + escapeHtml(d.worker || '?') + '</span>';
                html += '<span class="directive-action ' + actionColor + '">' + escapeHtml(actionLabels[d.action] || d.action || '?') + '</span>';
                html += '<span class="directive-detail">' + escapeHtml(d.reason || d.message || '') + '</span>';
                if (d.action === 'wait') {
                    html += '<button class="btn btn-sm btn-secondary opacity-half" id="directive-btn-' + i + '" onclick="applyDirective(' + i + ')">OK</button>';
                } else {
                    html += '<button class="btn btn-sm btn-secondary" id="directive-btn-' + i + '" onclick="applyDirective(' + i + ')">Apply</button>';
                }
                html += '</div>';
            }
        }
        // Conflicts
        const conflicts = data.conflicts || [];
        if (conflicts.length > 0) {
            html += '<div class="conflicts-card">';
            html += '<strong class="text-poppy">Conflicts Detected</strong>';
            for (const c of conflicts) {
                html += '<div class="text-base conflict-item">' + escapeHtml(typeof c === 'string' ? c : JSON.stringify(c)) + '</div>';
            }
            html += '</div>';
        }
        // Raw/unknown format fallback
        if (!html) {
            html = '<pre class="text-sm ws-pre-wrap">' + escapeHtml(JSON.stringify(data, null, 2)) + '</pre>';
        }
        return html;
    }

    function queenSummaryLine(type, data) {
        var w = escapeHtml(data.worker || data.worker_name || '?');
        if (type === 'completion') {
            var t = escapeHtml(data.task_title || 'task');
            return 'Mark \u201c' + t + '\u201d complete for <strong class="text-lavender">' + w + '</strong>';
        }
        if (type === 'assignment') {
            var t = escapeHtml(data.task_title || 'task');
            return 'Assign \u201c' + t + '\u201d to <strong class="text-lavender">' + w + '</strong>';
        }
        var a = data.action || 'wait';
        var labels = {
            send_message: 'Send command to <strong class="text-lavender">' + w + '</strong>',
            continue: 'Continue execution for <strong class="text-lavender">' + w + '</strong>',
            restart: 'Restart <strong class="text-lavender">' + w + '</strong>',
            complete_task: 'Complete task for <strong class="text-lavender">' + w + '</strong>',
            wait: 'No action needed for <strong class="text-lavender">' + w + '</strong>'
        };
        return labels[a] || escapeHtml(a) + ' — <strong class="text-lavender">' + w + '</strong>';
    }

    window.showQueenCompletion = function(data) {
        var modal = document.getElementById('queen-modal');
        var result = document.getElementById('queen-result');
        var confPct = Math.round((data.confidence || 0) * 100);
        var confClass = confPct >= 70 ? 'conf-high' : confPct >= 40 ? 'conf-mid' : 'conf-low';
        var html = '<div class="queen-card queen-card-complete">';
        html += '<div class="queen-card-header">';
        html += '<span class="conf-badge conf-high"><img src="/static/bees/honey-jar.svg" class="bee-icon bee-xs" alt="" style="margin-right:0.2rem">TASK COMPLETE</span>';
        html += '<span class="conf-badge ' + confClass + '">Confidence: ' + confPct + '%</span>';
        html += '</div>';
        html += '<div class="queen-summary">' + queenSummaryLine('completion', data) + '</div>';
        var compParts = [];
        if (data.assessment) compParts.push(escapeHtml(data.assessment));
        if (data.reasoning && data.reasoning !== data.assessment) compParts.push(escapeHtml(data.reasoning));
        if (compParts.length) {
            html += '<div class="resolution-block queen-text-block"><strong class="text-leaf text-base">Resolution</strong><br><span class="ws-pre-wrap">' + compParts.join(' ') + '</span></div>';
        }
        // Draft Response checkbox — only shown for email-sourced tasks
        var cbId = 'completion-draft-response';
        if (data.has_source_email) {
            html += '<label class="flex-center gap-xs text-base text-beeswax draft-label">';
            html += '<input type="checkbox" id="' + cbId + '" checked class="checkbox-leaf">';
            html += 'Draft Response &mdash; reply-all to source email</label>';
        }
        html += '</div>';
        if (data.proposal_id) {
            var pid = escapeHtml(data.proposal_id);
            html += '<div class="modal-footer">';
            html += '<button class="btn btn-approve" onclick="approveProposal(\'' + pid + '\',\'checkbox\');hideQueen();">Approve &amp; Complete</button>';
            html += '<button class="btn btn-reject-ghost" onclick="rejectProposal(\'' + pid + '\');hideQueen();">Reject</button>';
            html += '</div>';
        }
        result.innerHTML = html;
        modal.style.display = 'flex';
        document.getElementById('queen-apply-btn').style.display = 'none';
        document.querySelector('.queen-ask-footer').style.display = 'none';
        clearTimeout(queenAutoHideTimer);
        if (isTestMode) {
            queenAutoHideTimer = setTimeout(hideQueen, 4000);
        }
    };

    window.showQueenEscalation = function(data) {
        var modal = document.getElementById('queen-modal');
        var result = document.getElementById('queen-result');
        var confPct = Math.round((data.confidence || 0) * 100);
        var confClass = confPct >= 70 ? 'conf-high' : confPct >= 40 ? 'conf-mid' : 'conf-low';
        var actionLabels = {send_message: 'Send message', continue: 'Continue execution', restart: 'Restart worker', complete_task: 'Complete task', wait: 'Wait'};
        var html = '<div class="queen-card queen-card-escalation">';
        html += '<div class="queen-card-header">';
        html += '<span class="conf-badge conf-mid"><img src="/static/bees/surprised.svg" class="bee-icon bee-xs" alt="" style="margin-right:0.2rem">ESCALATION</span>';
        html += '<span class="conf-badge ' + confClass + '">Confidence: ' + confPct + '%</span>';
        html += '</div>';
        html += '<div class="queen-summary">' + queenSummaryLine('escalation', data) + '</div>';
        var analysisParts = [];
        if (data.assessment) analysisParts.push(escapeHtml(data.assessment));
        if (data.reasoning && data.reasoning !== data.assessment) analysisParts.push(escapeHtml(data.reasoning));
        if (analysisParts.length) {
            html += '<div class="mb-sm queen-text-block"><strong class="text-honey">Analysis</strong><br>' + analysisParts.join(' ') + '</div>';
        }
        if (data.action && data.action !== 'wait') {
            var label = actionLabels[data.action] || data.action;
            html += '<div class="queen-recommends-callout"><img src="/static/bees/queen.svg" class="bee-icon bee-sm" alt=""><span><strong class="text-honey">Queen recommends</strong>: <span class="text-lavender">' + escapeHtml(label) + '</span></span></div>';
        }
        if (data.message) {
            html += '<div class="queen-code-block mb-sm">' + escapeHtml(data.message) + '</div>';
        }
        html += '</div>';
        if (data.proposal_id) {
            html += '<div class="modal-footer">';
            html += '<button class="btn btn-approve" onclick="approveProposal(\'' + escapeHtml(data.proposal_id) + '\');hideQueen();">Approve</button>';
            html += '<button class="btn btn-reject-ghost" onclick="rejectProposal(\'' + escapeHtml(data.proposal_id) + '\');hideQueen();">Reject</button>';
            html += '</div>';
        }
        result.innerHTML = html;
        modal.style.display = 'flex';
        document.getElementById('queen-apply-btn').style.display = 'none';
        document.querySelector('.queen-ask-footer').style.display = 'none';
        clearTimeout(queenAutoHideTimer);
        if (isTestMode) {
            queenAutoHideTimer = setTimeout(hideQueen, 4000);
        }
    };

    function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    // --- Queen notification banners (non-blocking) ---
    var _bannerCount = 0;
    var _MAX_BANNERS = 5;

    window.showQueenBanner = function(type, data) {
        // Suppress banner if user is currently viewing this worker
        if (data.worker && data.worker === selectedWorker) return;

        var container = document.getElementById('queen-notifications');
        if (!container) return;

        // Cap visible banners
        while (container.children.length >= _MAX_BANNERS) {
            container.removeChild(container.firstChild);
        }

        var isEsc = type === 'esc';
        var bannerId = 'queen-banner-' + (++_bannerCount);
        var pid = data.proposal_id ? escapeHtml(data.proposal_id) : '';
        var worker = escapeHtml(data.worker || '?');
        var confPct = Math.round((data.confidence || 0) * 100);
        var assessment = escapeHtml(data.assessment || data.reasoning || '');

        var banner = document.createElement('div');
        banner.className = 'queen-banner ' + (isEsc ? 'queen-banner-esc' : 'queen-banner-done');
        banner.id = bannerId;
        if (pid) banner.dataset.proposalId = pid;

        var badgeClass = isEsc ? 'queen-banner-badge-esc' : 'queen-banner-badge-done';
        var badgeText = isEsc ? 'ESC' : 'DONE';

        var html = '<span class="queen-banner-badge ' + badgeClass + '">' + badgeText + '</span>';
        html += '<div class="queen-banner-body">';
        html += '<span class="queen-banner-worker">' + worker + '</span>';
        if (assessment) html += '<span class="queen-banner-assessment">' + assessment + '</span>';
        html += '</div>';
        html += '<div class="queen-banner-actions">';
        html += '<button class="btn btn-secondary" onclick="jumpToBannerWorker(\'' + worker + '\',\'' + bannerId + '\')">Jump</button>';
        if (pid) {
            var approveExtra = '';
            if (!isEsc && data.has_source_email) approveExtra = ',\'checkbox\'';
            html += '<button class="btn btn-approve" onclick="approveProposal(\'' + pid + '\'' + approveExtra + ');removeQueenBanner(\'' + bannerId + '\')">Approve</button>';
            html += '<button class="btn btn-secondary" onclick="rejectProposal(\'' + pid + '\');removeQueenBanner(\'' + bannerId + '\')">Dismiss</button>';
        }
        html += '</div>';

        banner.innerHTML = html;
        container.appendChild(banner);
    };

    window.jumpToBannerWorker = function(workerName, bannerId) {
        selectWorker(workerName);
    };

    window.removeQueenBanner = function(bannerId) {
        var el = document.getElementById(bannerId);
        if (el) el.remove();
    };

    window.clearQueenBanners = function() {
        var container = document.getElementById('queen-notifications');
        if (container) container.innerHTML = '';
    };

    // Also clear banners for a specific proposal when it's resolved
    window.removeQueenBannerByProposal = function(proposalId) {
        var container = document.getElementById('queen-notifications');
        if (!container) return;
        var banner = container.querySelector('[data-proposal-id="' + proposalId + '"]');
        if (banner) banner.remove();
    };

    // --- Queen modal auto-dismiss timer ---
    // Only auto-dismiss queen modals in test mode (so they don't block automated runs).
    var isTestMode = false;
    let queenAutoHideTimer = null;

    // --- Queen cooldown timer ---
    let queenCooldownTimer = null;

    function startQueenCooldown(seconds) {
        if (queenCooldownTimer) clearInterval(queenCooldownTimer);
        if (!seconds || seconds <= 0) return;
        let remaining = Math.ceil(seconds);
        const queenBtn = document.getElementById('queen-btn');
        const refreshBtn = document.getElementById('queen-refresh-btn');
        function updateBtns() {
            if (remaining > 0) {
                queenBtn.textContent = 'Ask Queen (' + remaining + 's)';
                queenBtn.disabled = true;
                refreshBtn.textContent = 'Re-analyze (' + remaining + 's)';
                refreshBtn.disabled = true;
                remaining--;
            } else {
                queenBtn.textContent = 'Ask Queen';
                queenBtn.disabled = false;
                refreshBtn.textContent = 'Re-analyze';
                refreshBtn.disabled = false;
                clearInterval(queenCooldownTimer);
                queenCooldownTimer = null;
            }
        }
        updateBtns();
        queenCooldownTimer = setInterval(updateBtns, 1000);
    }

    // --- Themed confirm dialog ---
    let confirmCallback = null;

    window.showConfirm = function(msg, onYes) {
        document.getElementById('confirm-msg').textContent = msg;
        confirmCallback = onYes;
        var yesBtn = document.getElementById('confirm-yes-btn');
        // Clone to remove old listeners
        var newBtn = yesBtn.cloneNode(true);
        yesBtn.parentNode.replaceChild(newBtn, yesBtn);
        newBtn.addEventListener('click', function() {
            var cb = confirmCallback;
            hideConfirm();
            if (cb) cb();
        });
        document.getElementById('confirm-modal').style.display = 'flex';
    };

    window.hideConfirm = function() {
        document.getElementById('confirm-modal').style.display = 'none';
        confirmCallback = null;
    };

    // --- Notification history (badge counter + server-fetched buzz) ---
    let unreadNotifications = 0;

    function addNotification(msg, warning) {
        // Increment badge unless buzz tab is active
        var activeTab = document.querySelector('.tab-content.active');
        if (!activeTab || activeTab.id !== 'tab-buzz') {
            unreadNotifications++;
            var badge = document.getElementById('notif-badge');
            if (badge) {
                badge.textContent = unreadNotifications > 99 ? '99+' : unreadNotifications;
                badge.style.display = 'inline-flex';
            }
            updateAppBadge(unreadNotifications);
            if (pageHidden) startTitleFlash(unreadNotifications);
        } else {
            refreshBuzzLog();
        }
    }

    function startTitleFlash(count) {
        pendingTitleCount = count;
        if (titleFlashTimer) clearInterval(titleFlashTimer);
        var show = true;
        titleFlashTimer = setInterval(function() {
            document.title = show ? '(' + pendingTitleCount + ') Event \u2014 Bee Hive' : ORIGINAL_TITLE;
            show = !show;
        }, 1000);
    }

    function stopTitleFlash() {
        if (titleFlashTimer) {
            clearInterval(titleFlashTimer);
            titleFlashTimer = null;
        }
        pendingTitleCount = 0;
        document.title = ORIGINAL_TITLE;
    }

    function updateAppBadge(count) {
        if ('setAppBadge' in navigator) {
            if (count > 0) {
                navigator.setAppBadge(count).catch(function() {});
            } else {
                navigator.clearAppBadge().catch(function() {});
            }
        }
    }

    // --- Browser notifications ---
    function updateNotifButton() {
        var btn = document.getElementById('notif-perm-btn');
        if (!btn) return;
        if (!('Notification' in window)) {
            btn.style.display = 'none';
            return;
        }
        if (Notification.permission === 'granted') {
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-active');
            btn.title = 'Browser notifications enabled';
        } else if (Notification.permission === 'denied') {
            btn.style.opacity = '0.4';
            btn.title = 'Browser notifications blocked — update in browser settings';
        }
    }

    window.requestNotifPermission = function() {
        if (!('Notification' in window)) {
            showToast('Browser does not support notifications', true);
            return;
        }
        if (Notification.permission === 'granted') {
            showToast('Notifications already enabled');
            var testOpts = { body: 'Notifications are working.', icon: '/static/bees/png/happy.png', badge: '/static/icon-192.png' };
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(function(reg) { reg.showNotification("Swarm's Bee Hive", testOpts); });
            } else {
                new Notification("Swarm's Bee Hive", testOpts);
            }
            return;
        }
        if (Notification.permission === 'denied') {
            showToast('Notifications blocked — allow in browser settings', true);
            return;
        }
        Notification.requestPermission().then(function(perm) {
            if (perm === 'granted') {
                showToast('Browser notifications enabled');
                // Show a test notification via SW if available
                var testOpts = { body: 'Notifications are now active.', icon: '/static/bees/png/happy.png', badge: '/static/icon-192.png' };
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.ready.then(function(reg) { reg.showNotification("Swarm's Bee Hive", testOpts); });
                } else {
                    new Notification("Swarm's Bee Hive", testOpts);
                }
            } else {
                showToast('Notification permission denied', true);
            }
            updateNotifButton();
        });
    };

    var NOTIF_ICON_MAP = {
        'Worker Down': '/static/bees/png/sleeping.png',
        'Escalation': '/static/bees/png/surprised.png',
        'Task Failed': '/static/bees/png/angry.png',
        'Queen Proposal': '/static/bees/png/queen.png',
        'Queen Auto-Action': '/static/bees/png/queen.png',
        'Queen needs your input': '/static/bees/png/thinking.png',
        'Task complete': '/static/bees/png/honey-jar.png',
        'Draft Failed': '/static/bees/png/angry.png',
        'Task Send Failed': '/static/bees/png/angry.png',
    };

    function notifyBrowser(title, body, vibrate) {
        // Vibrate on Queen-attention events (works even when tab is visible)
        if (vibrate && 'vibrate' in navigator) {
            try { navigator.vibrate([200, 100, 200]); } catch(e) {}
        }
        if (!('Notification' in window)) return;
        if (Notification.permission !== 'granted') return;
        var opts = {
            body: body,
            icon: NOTIF_ICON_MAP[title] || '/static/bees/png/happy.png',
            badge: '/static/icon-192.png',
            tag: 'swarm-' + title.replace(/\s+/g, '-').toLowerCase(),
            vibrate: vibrate ? [200, 100, 200] : undefined
        };
        try {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(function(reg) {
                    reg.showNotification(title, opts);
                });
            } else {
                new Notification(title, opts);
            }
        } catch(e) {}
    }

    // --- Task filter switcher (persisted in localStorage) ---
    window.switchTaskFilter = function(filter) {
        if (filter === 'all') {
            activeTaskFilters.clear();
        } else if (activeTaskFilters.has(filter)) {
            activeTaskFilters.delete(filter);
        } else {
            activeTaskFilters.add(filter);
        }
        try { localStorage.setItem('swarm_task_filter', Array.from(activeTaskFilters).join(',')); } catch(e) {}
        document.querySelectorAll('.filter-chip[data-filter]').forEach(function(c) {
            if (c.dataset.filter === 'all') c.classList.toggle('active', activeTaskFilters.size === 0);
            else c.classList.toggle('active', activeTaskFilters.has(c.dataset.filter));
        });
        refreshTasks();
    };

    window.switchPriorityFilter = function(priority) {
        if (priority === 'all') {
            activePriorityFilters.clear();
        } else if (activePriorityFilters.has(priority)) {
            activePriorityFilters.delete(priority);
        } else {
            activePriorityFilters.add(priority);
        }
        try { localStorage.setItem('swarm_priority_filter', Array.from(activePriorityFilters).join(',')); } catch(e) {}
        document.querySelectorAll('.priority-chip').forEach(function(c) {
            if (c.dataset.priority === 'all') c.classList.toggle('active', activePriorityFilters.size === 0);
            else c.classList.toggle('active', activePriorityFilters.has(c.dataset.priority));
        });
        refreshTasks();
    };

    // Restore saved filters on page load
    (function() {
        try {
            var savedFilter = localStorage.getItem('swarm_task_filter');
            var savedPriority = localStorage.getItem('swarm_priority_filter');
            if (savedFilter) savedFilter.split(',').forEach(function(f) { if (f) activeTaskFilters.add(f); });
            if (savedPriority) savedPriority.split(',').forEach(function(p) { if (p) activePriorityFilters.add(p); });
            // Update chip visuals
            document.querySelectorAll('.filter-chip[data-filter]').forEach(function(c) {
                if (c.dataset.filter === 'all') c.classList.toggle('active', activeTaskFilters.size === 0);
                else c.classList.toggle('active', activeTaskFilters.has(c.dataset.filter));
            });
            document.querySelectorAll('.priority-chip').forEach(function(c) {
                if (c.dataset.priority === 'all') c.classList.toggle('active', activePriorityFilters.size === 0);
                else c.classList.toggle('active', activePriorityFilters.has(c.dataset.priority));
            });
            if (activeTaskFilters.size || activePriorityFilters.size) refreshTasks();
        } catch(e) {}
    })();

    // --- Worker group toggle ---
    window.toggleGroup = function(groupName) {
        var header = document.querySelector('.group-header[data-group="' + CSS.escape(groupName) + '"]');
        if (!header) return;
        var section = header.parentElement;
        if (!section) return;
        section.classList.toggle('group-collapsed');
        // Persist in localStorage
        var collapsed = JSON.parse(localStorage.getItem('swarm-groups-collapsed') || '{}');
        collapsed[groupName] = section.classList.contains('group-collapsed');
        localStorage.setItem('swarm-groups-collapsed', JSON.stringify(collapsed));
    };

    // --- Bee icon map for toasts & notifications ---
    var BEE = {
        happy: '/static/bees/happy.svg',
        angry: '/static/bees/angry.svg',
        surprised: '/static/bees/surprised.svg',
        thinking: '/static/bees/thinking.svg',
        queen: '/static/bees/queen.svg',
        sleeping: '/static/bees/sleeping.svg',
        honeyJar: '/static/bees/honey-jar.svg',
        typing: '/static/bees/typing.svg',
        flower: '/static/bees/flower.svg',
        zooming: '/static/bees/zooming.svg',
        delivering: '/static/bees/delivering.svg',
        cool: '/static/bees/cool.svg',
        flyingRight: '/static/bees/flying-right.svg',
        worker: '/static/bees/worker.svg',
    };

    // --- Update banner ---
    function showUpdateBanner(data) {
        var el = document.getElementById('update-banner');
        var txt = document.getElementById('update-banner-text');
        var msg = 'Update available: <strong>' + escapeHtml(data.current_version) + '</strong> → <strong>' + escapeHtml(data.remote_version) + '</strong>';
        if (data.commit_sha) msg += '  (' + escapeHtml(data.commit_sha) + ': ' + escapeHtml(data.commit_message || '') + ')';
        txt.innerHTML = msg;
        el.style.display = 'block';
    }
    window.hideUpdateBanner = function() {
        document.getElementById('update-banner').style.display = 'none';
    };
    window.installUpdate = function() {
        if (!confirm('Install update and restart swarm? Workers will keep running.')) return;
        showUpdateProgress('Installing update...');
        fetch('/action/update-and-restart', { method: 'POST' })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.restarting) {
                    showToast('Update installed — restarting server...');
                    hideUpdateBanner();
                    waitForRestart();
                } else {
                    showToast('Update failed: ' + (data.output || 'unknown error').substring(0, 200), true);
                    resetUpdateBanner();
                }
            })
            .catch(function() {
                // Server may have already shut down — start polling
                waitForRestart();
            });
    };
    function showUpdateProgress(line) {
        var el = document.getElementById('update-banner');
        var txt = document.getElementById('update-banner-text');
        el.style.display = 'block';
        txt.innerHTML = '<span class="update-spinner"></span> ' + escapeHtml(line);
    }
    function resetUpdateBanner() {
        var txt = document.getElementById('update-banner-text');
        if (txt) txt.innerHTML = '';
        document.getElementById('update-banner').style.display = 'none';
    }
    function waitForRestart() {
        var attempts = 0;
        var maxAttempts = 60;
        var interval = setInterval(function() {
            attempts++;
            fetch('/api/health', { method: 'GET' })
                .then(function(r) { if (r.ok) { clearInterval(interval); location.reload(); } })
                .catch(function() {});
            if (attempts >= maxAttempts) {
                clearInterval(interval);
                showToast('Server did not come back — check terminal', true);
            }
        }, 2000);
    }

    // --- Toast notifications ---
    function showToast(msg, warning, beeSrc) {
        const container = document.getElementById('toasts');
        const toast = document.createElement('div');
        toast.className = 'toast' + (warning ? ' toast-warning' : '');
        toast.style.display = 'flex';
        toast.style.alignItems = 'center';
        var bee = beeSrc || (warning ? BEE.angry : BEE.happy);
        toast.innerHTML = '<img src="' + bee + '" class="bee-icon bee-md toast-bee" alt="">' + escapeHtml(msg);
        container.appendChild(toast);
        setTimeout(function() { toast.remove(); }, 3500);
        addNotification(msg, warning);
    }

    // --- Launch ---
    let launchConfig = null;

    window.showLaunch = function() {
        const modal = document.getElementById('launch-modal');
        const body = document.getElementById('launch-body');
        modal.style.display = 'flex';
        body.innerHTML = '<p class="text-muted">Loading config...</p>';

        fetch('/partials/launch-config')
            .then(r => r.json())
            .then(data => {
                launchConfig = data;
                let html = '';
                // Group preset buttons
                if (data.groups && data.groups.length > 0) {
                    html += '<div class="mb-md">';
                    html += '<label class="launch-label">Quick select group:</label><br>';
                    for (const g of data.groups) {
                        html += '<button class="btn btn-sm btn-secondary launch-group-btn launch-btn-gap" data-group="' + escapeHtml(g.name) + '">' + escapeHtml(g.name) + '</button>';
                    }
                    html += '</div>';
                }
                // Worker checkboxes — disable already-running workers
                html += '<div class="launch-scroll">';
                for (const w of data.workers) {
                    const running = w.running;
                    html += '<label class="launch-worker-label" style="cursor:' + (running ? 'default' : 'pointer') + ';color:' + (running ? 'var(--muted)' : 'var(--beeswax)') + ';">';
                    html += '<input type="checkbox" class="launch-worker-cb cb-spaced" value="' + escapeHtml(w.name) + '"' + (running ? ' disabled' : '') + '>';
                    html += escapeHtml(w.name);
                    if (running) {
                        html += ' <span class="worker-running-badge">(running)</span>';
                    }
                    html += ' <span class="worker-path-text">(' + escapeHtml(w.path) + ')</span>';
                    html += '</label>';
                }
                html += '</div>';
                body.innerHTML = html;
            })
            .catch(() => {
                body.innerHTML = '<p class="text-poppy">Failed to load config</p>';
            });
    }

    window.hideLaunch = function() {
        document.getElementById('launch-modal').style.display = 'none';
    }

    function selectLaunchGroup(groupName) {
        if (!launchConfig) return;
        const group = launchConfig.groups.find(g => g.name === groupName);
        if (!group) return;
        const members = new Set(group.workers.map(n => n.toLowerCase()));
        document.querySelectorAll('.launch-worker-cb').forEach(cb => {
            cb.checked = members.has(cb.value.toLowerCase());
        });
    }

    window.launchSelected = function() {
        const checked = [];
        document.querySelectorAll('.launch-worker-cb:checked').forEach(cb => checked.push(cb.value));
        if (!checked.length) { showToast('No workers selected', true); return; }
        doLaunch(checked.join(','));
    }

    window.launchAll = function() {
        doLaunch('');
    }

    function doLaunch(workers) {
        // Replace modal content with launch progress
        var body = document.getElementById('launch-body');
        var footer = document.querySelector('#launch-modal .modal-footer');
        body.innerHTML = '<div style="text-align:center;padding:2rem 0"><div class="spinner" style="margin:0 auto 1rem"></div><p class="text-honey" id="launch-status">Launching workers...</p><p class="text-muted text-sm">This takes 2-3 seconds per worker</p></div>';
        if (footer) footer.style.display = 'none';

        fetch('/action/launch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: workers ? 'workers=' + encodeURIComponent(workers) : ''
        })
        .then(r => r.json())
        .then(data => {
            if (data.error) {
                showToast('Launch failed: ' + data.error, true);
            } else {
                showToast('Launched ' + data.count + ' worker(s)');
                refreshWorkers();
                refreshStatus();
            }
            hideLaunch();
            if (footer) footer.style.display = '';
        })
        .catch(() => { showToast('Launch request failed', true); hideLaunch(); if (footer) footer.style.display = ''; });
    }

    // --- Spawn Worker ---
    window.showSpawn = function() {
        const modal = document.getElementById('spawn-modal');
        modal.style.display = 'flex';
        document.getElementById('spawn-name').value = '';
        document.getElementById('spawn-path').value = '';
        document.getElementById('spawn-name').focus();

        // Load config paths as presets
        fetch('/partials/launch-config')
            .then(r => r.json())
            .then(data => {
                const presets = document.getElementById('spawn-presets');
                if (!data.workers || !data.workers.length) { presets.innerHTML = ''; return; }
                const paths = [...new Set(data.workers.map(w => w.path))];
                let html = '<label class="launch-label text-xs">Quick fill from config:</label><br>';
                for (const w of data.workers) {
                    if (!w.running) {
                        html += '<button type="button" class="btn btn-sm btn-secondary spawn-preset-btn spawn-btn-gap" data-name="' + escapeHtml(w.name) + '" data-path="' + escapeHtml(w.path) + '">' + escapeHtml(w.name) + '</button>';
                    }
                }
                presets.innerHTML = html;
            });
    }

    window.hideSpawn = function() {
        document.getElementById('spawn-modal').style.display = 'none';
    }

    window.doSpawn = function() {
        const name = document.getElementById('spawn-name').value.trim();
        const path = document.getElementById('spawn-path').value.trim();
        if (!name || !path) { showToast('Name and path are required', true); return; }

        fetch('/action/spawn', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'name=' + encodeURIComponent(name) + '&path=' + encodeURIComponent(path)
        })
        .then(r => r.json())
        .then(data => {
            if (data.error) {
                showToast('Spawn failed: ' + data.error, true);
            } else {
                showToast('Spawned ' + data.worker);
                hideSpawn();
                refreshWorkers();
                refreshStatus();
            }
        })
        .catch(() => showToast('Spawn request failed', true));
    }

    // --- Shutdown dialog ---
    window.killSession = function() {
        document.getElementById('shutdown-modal').style.display = 'flex';
    }

    window.hideShutdown = function() {
        document.getElementById('shutdown-modal').style.display = 'none';
    }

    window.doRestartServer = function() {
        hideShutdown();
        showToast('Server restarting...');
        fetch('/api/server/restart', { method: 'POST' }).catch(function() {});
        waitForRestart();
    }

    function tryCloseWindow() {
        // PWA standalone windows can be closed; regular tabs cannot
        try { window.close(); } catch(e) {}
        // If window.close() didn't work (regular tab), show offline page
        setTimeout(function() { location.replace('/offline.html'); }, 500);
    }

    window.doStopServer = function() {
        hideShutdown();
        showToast('Web server stopping...');
        fetch('/action/stop-server', { method: 'POST' }).catch(function() {});
        setTimeout(tryCloseWindow, 300);
    }

    window.doKillEverything = function() {
        detachInlineTerminal();
        hideShutdown();
        showToast('Killing everything...');
        var fd = new FormData();
        fd.append('all', '1');
        fetch('/action/kill-session', { method: 'POST', body: fd }).catch(function() {});
        setTimeout(function() {
            fetch('/action/stop-server', { method: 'POST' }).catch(function() {});
            setTimeout(tryCloseWindow, 300);
        }, 500);
    }

    // --- Drag-and-drop attachments (unified modal) ---
    ;(function() {
        var dropzone = document.getElementById('tm-dropzone');
        var fileInput = document.getElementById('tm-file');

        if (!dropzone || !fileInput) return;

        dropzone.addEventListener('click', function() { fileInput.click(); });

        dropzone.addEventListener('dragenter', function(e) { e.preventDefault(); dropzone.style.borderColor = 'var(--honey)'; });
        dropzone.addEventListener('dragover', function(e) { e.preventDefault(); });
        dropzone.addEventListener('dragleave', function() { dropzone.style.borderColor = 'var(--border)'; });
        dropzone.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropzone.style.borderColor = 'var(--border)';
            for (var i = 0; i < e.dataTransfer.files.length; i++) {
                handleTaskFile(e.dataTransfer.files[i]);
            }
        });

        fileInput.addEventListener('change', function() {
            for (var i = 0; i < fileInput.files.length; i++) {
                handleTaskFile(fileInput.files[i]);
            }
            fileInput.value = '';
        });
    })();

    function handleTaskFile(file) {
        if (taskModalMode === 'edit' && taskModalId) {
            // Upload immediately for existing tasks
            var fd = new FormData();
            fd.append('task_id', taskModalId);
            fd.append('file', file);
            fetch('/action/task/upload', { method: 'POST', body: fd })
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    if (data.status === 'uploaded') {
                        showToast('Attachment uploaded');
                        addThumbnail(data.path);
                        refreshTasks();
                    } else {
                        showToast('Upload failed: ' + (data.error || 'unknown'), true);
                    }
                })
                .catch(function() { showToast('Upload failed', true); });
        } else {
            // Queue file for upload after task creation
            taskModalPendingFiles.push(file);
            addLocalThumbnail(file);
            showToast('File queued — will upload on create');
        }
    }

    function isImageFile(nameOrType) {
        return /^image\//i.test(nameOrType) || /\.(png|jpe?g|gif|webp|svg|bmp|ico)$/i.test(nameOrType);
    }

    function addThumbnail(path) {
        var container = document.getElementById('tm-attachments');
        var basename = path.split('/').pop();
        if (isImageFile(basename)) {
            var img = document.createElement('img');
            img.src = '/uploads/' + encodeURIComponent(basename);
            img.className = 'task-attachment-img';
            container.appendChild(img);
        } else {
            var chip = document.createElement('span');
            chip.textContent = basename;
            chip.className = 'task-attachment-file';
            container.appendChild(chip);
        }
    }

    function addLocalThumbnail(file) {
        var container = document.getElementById('tm-attachments');
        if (isImageFile(file.type || file.name)) {
            var img = document.createElement('img');
            img.src = URL.createObjectURL(file);
            img.className = 'task-attachment-img';
            img.onload = function() { URL.revokeObjectURL(img.src); };
            container.appendChild(img);
        } else {
            var chip = document.createElement('span');
            chip.textContent = file.name;
            chip.className = 'task-attachment-file';
            container.appendChild(chip);
        }
    }

    // --- Paste handler: email content + images ---
    // Prevent browser from navigating to dropped files anywhere on the page.
    // Specific drop zones (terminal, task tab, dropzone) call stopPropagation
    // so their handlers still fire normally.
    document.addEventListener('dragover', function(e) { e.preventDefault(); });
    document.addEventListener('drop', function(e) {
        e.preventDefault();
        // If an image was dropped outside a valid drop zone, try to upload it
        // to the active terminal as a fallback.
        if (e.dataTransfer && e.dataTransfer.files.length > 0) {
            var file = e.dataTransfer.files[0];
            if (file.type && file.type.indexOf('image') !== -1 && typeof uploadAndPaste === 'function') {
                uploadAndPaste(file);
            }
        }
    });

    document.addEventListener('paste', function(e) {
        var cd = e.clipboardData;
        if (!cd) return;
        var modalOpen = document.getElementById('task-modal').style.display !== 'none';
        var html = cd.getData('text/html');

        // Rich email paste: if HTML is substantial, treat as email import
        if (html && html.length > 200) {
            var descEl = document.getElementById('tm-desc');
            var focused = document.activeElement;
            // Never intercept when user is typing in an input/textarea outside the task modal
            var inOtherInput = (focused.tagName === 'INPUT' || focused.tagName === 'TEXTAREA')
                && !focused.closest('#task-modal');
            if (inOtherInput) { /* let the paste through to the focused field */ }
            // Only intercept if: modal is closed, OR desc is empty/not focused
            else if (!modalOpen || (descEl.value.trim() === '' && focused !== descEl)) {
                e.preventDefault();
                importPastedEmail(html, cd);
                return;
            }
        }

        // Image-only paste (screenshot etc.) — only when modal is open
        if (!modalOpen) return;
        var items = cd.items;
        if (!items) return;
        var handledImage = false;
        for (var i = 0; i < items.length; i++) {
            if (items[i].kind === 'file' && /^image\//.test(items[i].type)) {
                var file = items[i].getAsFile();
                if (file) { handleTaskFile(file); handledImage = true; }
            }
        }
        if (handledImage) e.preventDefault();
    });

    function importPastedEmail(html, clipboardData) {
        // Debug: log clipboard contents
        if (clipboardData && clipboardData.items) {
            for (var di = 0; di < clipboardData.items.length; di++) {
                var ci = clipboardData.items[di];
                console.log('[paste] item', di, 'kind:', ci.kind, 'type:', ci.type);
            }
        }

        // Extract text from HTML
        var tmp = document.createElement('div');
        tmp.innerHTML = html;

        // Try to find a subject
        var subject = '';
        var subjectEl = tmp.querySelector('[class*="Subject"], [class*="subject"]');
        if (subjectEl) subject = subjectEl.textContent.trim();

        // Extract plain text body
        var body = tmp.textContent || tmp.innerText || '';
        body = body.replace(/\r\n/g, '\n').replace(/[ \t]+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();

        // Collect all images from clipboard items (blobs)
        var imageFiles = [];
        if (clipboardData && clipboardData.items) {
            for (var j = 0; j < clipboardData.items.length; j++) {
                var item = clipboardData.items[j];
                if (item.kind === 'file' && /^image\//.test(item.type)) {
                    var f = item.getAsFile();
                    if (f) imageFiles.push(f);
                }
            }
        }

        // Extract base64 data-URI images from HTML
        var dataImgs = tmp.querySelectorAll('img[src^="data:image"]');
        for (var i = 0; i < dataImgs.length; i++) {
            var src = dataImgs[i].getAttribute('src');
            var match = src.match(/^data:(image\/[\w+]+);base64,(.+)$/);
            if (match) {
                try {
                    var mime = match[1];
                    var ext = mime.split('/')[1] || 'png';
                    var binary = atob(match[2]);
                    var bytes = new Uint8Array(binary.length);
                    for (var b = 0; b < binary.length; b++) bytes[b] = binary.charCodeAt(b);
                    var blob = new Blob([bytes], { type: mime });
                    imageFiles.push(new File([blob], 'image_' + (i + 1) + '.' + ext, { type: mime }));
                } catch (e) { console.warn('[paste] failed to decode data URI image', e); }
            }
        }

        // Collect fetchable and unfetchable image URLs
        var allImgs = tmp.querySelectorAll('img');
        var externalUrls = [];
        var blobCount = 0;
        for (var ei = 0; ei < allImgs.length; ei++) {
            var imgSrc = allImgs[ei].getAttribute('src') || '';
            if (imgSrc.startsWith('blob:')) { blobCount++; continue; }
            if (imgSrc && !imgSrc.startsWith('data:') && !imgSrc.startsWith('cid:')) {
                externalUrls.push(imgSrc);
            }
        }
        console.log('[paste] found', imageFiles.length, 'clipboard images,',
            dataImgs.length, 'data-URI,', externalUrls.length, 'fetchable,', blobCount, 'blob (unfetchable)');

        // Open task modal pre-populated
        openTaskModal('create', { title: subject, desc: body });

        // Queue already-available images
        for (var k = 0; k < imageFiles.length; k++) {
            taskModalPendingFiles.push(imageFiles[k]);
            addLocalThumbnail(imageFiles[k]);
        }

        // Fetch external images through server proxy and add as attachments
        if (externalUrls.length > 0) {
            showToast('Fetching ' + externalUrls.length + ' embedded image(s)...');
            var fetched = 0;
            externalUrls.forEach(function(url, idx) {
                fetch('/action/fetch-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: 'url=' + encodeURIComponent(url)
                })
                .then(function(r) { return r.ok ? r.json() : null; })
                .then(function(data) {
                    if (data && data.path) {
                        taskModalAttachmentPaths.push(data.path);
                        addThumbnail(data.path);
                        fetched++;
                    }
                })
                .catch(function() {})
                .finally(function() {
                    if (idx === externalUrls.length - 1 && fetched > 0) {
                        showToast(fetched + ' embedded image(s) captured');
                    }
                });
            });
        }

        var msg = 'Email pasted';
        if (imageFiles.length > 0) msg += ' with ' + imageFiles.length + ' image(s)';
        if (blobCount > 0 && imageFiles.length === 0 && externalUrls.length === 0) {
            msg += ' — ' + blobCount + ' image(s) could not be extracted (Outlook Web limitation)';
        }
        showToast(msg);
    }

    // --- Ctrl+Enter submits from modal inputs ---
    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            var active = document.activeElement;
            // Task modal
            if (document.getElementById('task-modal').style.display !== 'none') {
                if (active && (active.id === 'tm-desc' || active.id === 'tm-title' || active.id === 'tm-deps')) {
                    e.preventDefault();
                    submitTaskModal();
                    return;
                }
            }
            // Broadcast modal
            if (document.getElementById('broadcast-modal').style.display !== 'none') {
                if (active && active.id === 'broadcast-input') {
                    e.preventDefault();
                    sendBroadcast();
                    return;
                }
            }
            // Spawn modal
            if (document.getElementById('spawn-modal').style.display !== 'none') {
                if (active && (active.id === 'spawn-name' || active.id === 'spawn-path')) {
                    e.preventDefault();
                    doSpawn();
                    return;
                }
            }
        }
    });

    // --- Periodic refresh (fallback if WS drops — heartbeat covers most updates) ---
    setInterval(function() {
        refreshWorkers();
        refreshStatus();
        refreshTasks();
        refreshBuzzLog();
        if (selectedWorker) refreshDetail();
    }, 30000);

    // --- Event delegation (avoids inline onclick + template escaping issues) ---
    document.addEventListener('click', function(e) {
        // Worker item click
        var item = e.target.closest('.worker-item');
        if (item && item.dataset.worker) {
            selectWorker(item.dataset.worker);
            return;
        }
        // Proposal View button
        var viewBtn = e.target.closest('.view-proposal-btn');
        if (viewBtn) {
            showProposalDetail(viewBtn.dataset.proposalId);
            return;
        }
        // Task assign button
        var assignBtn = e.target.closest('.assign-task-btn');
        if (assignBtn) {
            assignTask(assignBtn.dataset.taskId, assignBtn.dataset.taskTitle);
            return;
        }
        // Task complete button
        var completeBtn = e.target.closest('.complete-task-btn');
        if (completeBtn) {
            completeTask(completeBtn.dataset.taskId);
            return;
        }
        // Task remove button
        var removeBtn = e.target.closest('.remove-task-btn');
        if (removeBtn) {
            removeTask(removeBtn.dataset.taskId);
            return;
        }
        // Task fail button
        var failBtn = e.target.closest('.fail-task-btn');
        if (failBtn) {
            failTask(failBtn.dataset.taskId);
            return;
        }
        // Task unassign button
        var unassignBtn = e.target.closest('.unassign-task-btn');
        if (unassignBtn) {
            unassignTask(unassignBtn.dataset.taskId);
            return;
        }
        // Reopen task button
        var reopenBtn = e.target.closest('.reopen-task-btn');
        if (reopenBtn) {
            reopenTask(reopenBtn.dataset.taskId);
            return;
        }
        // Retry draft button
        var retryBtn = e.target.closest('.retry-draft-btn');
        if (retryBtn) {
            retryDraft(retryBtn.dataset.taskId);
            return;
        }
        // Task edit button
        var editBtn = e.target.closest('.edit-task-btn');
        if (editBtn) {
            showEditTask(editBtn.dataset.taskId, editBtn.dataset.taskTitle, editBtn.dataset.taskDesc, editBtn.dataset.taskPriority, editBtn.dataset.taskType || '', editBtn.dataset.taskTags, editBtn.dataset.taskDeps || '', editBtn.dataset.taskResolution || '', editBtn.dataset.taskStatus || '');
            return;
        }
        // Task history toggle
        var histBtn = e.target.closest('.history-task-btn');
        if (histBtn) {
            var tid = histBtn.dataset.taskId;
            var panel = document.getElementById('task-history-' + tid);
            if (panel) {
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    panel.innerHTML = '<span class="spinner spinner-margin"></span>';
                    fetch('/partials/task-history/' + encodeURIComponent(tid))
                        .then(function(r) { return r.text(); })
                        .then(function(html) { panel.innerHTML = html; });
                } else {
                    panel.style.display = 'none';
                }
            }
            return;
        }
        // Launch group preset button
        var groupBtn = e.target.closest('.launch-group-btn');
        if (groupBtn) {
            selectLaunchGroup(groupBtn.dataset.group);
            return;
        }
        // Spawn preset button
        var spawnBtn = e.target.closest('.spawn-preset-btn');
        if (spawnBtn) {
            document.getElementById('spawn-name').value = spawnBtn.dataset.name;
            document.getElementById('spawn-path').value = spawnBtn.dataset.path;
            return;
        }
        // Group header click (collapse/expand)
        var groupHeader = e.target.closest('.group-header');
        if (groupHeader && groupHeader.dataset.group) {
            toggleGroup(groupHeader.dataset.group);
            return;
        }
    });

    // --- Worker cycling (Ctrl+Tab / Alt+] / Alt+[) ---
    function getVisibleWorkerItems() {
        var items = [];
        document.querySelectorAll('.worker-item').forEach(function(el) {
            // Skip workers inside collapsed groups
            var group = el.closest('.group-body');
            if (group && group.style.display === 'none') return;
            items.push(el);
        });
        return items;
    }
    function cycleWorker(direction) {
        var items = getVisibleWorkerItems();
        if (items.length === 0) return;
        var idx = -1;
        for (var i = 0; i < items.length; i++) {
            if (items[i].dataset.worker === selectedWorker) { idx = i; break; }
        }
        var next = (idx + direction + items.length) % items.length;
        var item = items[next];
        selectWorker(item.dataset.worker);
    }
    document.addEventListener('keydown', function(e) {
        // Skip when terminal modal or inline terminal is focused
        if (document.getElementById('terminal-modal').style.display !== 'none') return;
        if (inlineTerm && inlineTerm.textarea && document.activeElement === inlineTerm.textarea) return;
        // Ctrl+Tab / Shift+Ctrl+Tab (works in standalone PWA mode)
        if (e.key === 'Tab' && e.ctrlKey) {
            e.preventDefault();
            cycleWorker(e.shiftKey ? -1 : 1);
            return;
        }
        // Alt+] / Alt+[ (works in browser tab mode)
        if (e.altKey && (e.key === ']' || e.key === '[')) {
            e.preventDefault();
            cycleWorker(e.key === ']' ? 1 : -1);
            return;
        }
    });

    // --- Keyboard shortcuts (Alt+letter) ---
    document.addEventListener('keydown', function(e) {
        if (!e.altKey) return;
        // When modal terminal is attached, let everything through to xterm
        if (document.getElementById('terminal-modal').style.display !== 'none') return;
        // When inline terminal is focused, let everything through
        if (inlineTerm && inlineTerm.textarea && document.activeElement === inlineTerm.textarea) return;

        switch (e.key.toLowerCase()) {
            case 'b': toggleDrones(); break;
            case 'a': continueAll(); break;
            case 'k': killWorker(); break;
            case 'r': reviveWorker(); break;
            case 'x': window.location.href = '/'; break;
            case 'q': askQueen(); break;
            case 'n': showCreateTask(); break;
            case 'h': killSession(); break;
            default: return;
        }
        e.preventDefault();
    });

    // --- Header clock (local time) ---
    function updateClock() {
        var el = document.getElementById('header-clock');
        if (el) {
            var now = new Date();
            el.textContent = now.toLocaleTimeString('en-US', { hour12: true });
        }
    }
    setInterval(updateClock, 1000);
    updateClock();

    // Boot — prompt for API password if needed for WebSocket auth
    {% if ws_auth_required %}
    if (!wsToken()) {
        const pw = prompt('API password required for live updates:');
        if (pw) sessionStorage.setItem('swarm_api_password', pw);
    }
    {% endif %}
    // Restore task search from localStorage
    (function() {
        var searchInput = document.getElementById('task-search');
        if (searchInput && activeSearchQuery) {
            searchInput.value = activeSearchQuery;
        }
    })();

    function onAppFocus() {
        pageHidden = false;
        stopTitleFlash();
        updateAppBadge(0);
        var activeTab = document.querySelector('.tab-content.active');
        if (activeTab && activeTab.id === 'tab-buzz') {
            unreadNotifications = 0;
            var badge = document.getElementById('notif-badge');
            if (badge) badge.style.display = 'none';
        }
        // Reconnect terminal WS if it died while tab was hidden
        if (activeTermWorker) {
            var focusEntry = termCache.get(activeTermWorker);
            if (focusEntry) {
                if (!focusEntry.ws || focusEntry.ws.readyState !== WebSocket.OPEN) {
                    focusEntry.reconnectAttempts = 0;
                    connectTermEntryWs(activeTermWorker, focusEntry);
                } else {
                    focusEntry.term.focus();
                }
            }
        }
    }
    document.addEventListener('visibilitychange', function() {
        pageHidden = document.hidden;
        if (!pageHidden) onAppFocus();
    });
    window.addEventListener('focus', onAppFocus);

    updateNotifButton();
    updateAppBadge(0);
    connect();

    // Auto-open launch modal on cold start (zero workers)
    {% if worker_count == 0 %}
    showLaunch();
    {% endif %}

    // Restore selected worker on page load (e.g. navigating back from Config)
    if (selectedWorker) {
        (function restoreWorker() {
            if (typeof Terminal === 'undefined') {
                setTimeout(restoreWorker, 50);
                return;
            }
            var item = document.querySelector('.worker-item[data-worker="' + selectedWorker + '"]');
            if (item) selectWorker(selectedWorker);
        })();
    }

    // Re-select worker after HTMX swaps the worker list
    document.body.addEventListener('htmx:afterSwap', function(e) {
        if (e.detail.target.id === 'worker-list') {
            if (selectedWorker) {
                var taskText = '';
                var foundWorker = false;
                document.querySelectorAll('.worker-item').forEach(function(el) {
                    el.classList.toggle('selected', el.dataset.worker === selectedWorker);
                    if (el.dataset.worker === selectedWorker) {
                        foundWorker = true;
                        var taskEl = el.querySelector('.worker-task');
                        if (taskEl) taskText = taskEl.textContent.trim();
                    }
                });
                if (foundWorker) {
                    document.getElementById('detail-title').textContent = selectedWorker + (taskText ? ' — ' + taskText : ' — Detail');
                    document.getElementById('terminal-actions').style.display = 'flex';
                } else {
                    selectedWorker = null;
                    try { sessionStorage.removeItem('swarm_selected_worker'); } catch(e2) {}
                }
            }
            // Restore group collapse state from localStorage
            var collapsed = JSON.parse(localStorage.getItem('swarm-groups-collapsed') || '{}');
            Object.keys(collapsed).forEach(function(gName) {
                if (collapsed[gName]) {
                    var header = document.querySelector('.group-header[data-group="' + gName + '"]');
                    if (header && header.parentElement) header.parentElement.classList.add('group-collapsed');
                }
            });
        }
        // Update task summary after task list swap
        if (e.detail.target.id === 'task-list') {
            const summary = e.detail.target.querySelector('[data-summary]');
            if (summary) {
                document.getElementById('task-summary').textContent = summary.dataset.summary;
            }
            // Highlight tasks assigned to selected worker
            if (selectedWorker) {
                document.querySelectorAll('.task-item').forEach(function(el) {
                    el.classList.toggle('assigned-to-selected', el.dataset.worker === selectedWorker);
                });
            }
        }
        // Auto-scroll panels to bottom so latest content is visible
        // Skip detail-body when inline terminal is active (it's already live)
        var tid = e.detail.target.id;
        if (tid === 'drone-log' || tid === 'task-list') {
            e.detail.target.scrollTop = e.detail.target.scrollHeight;
        }
        if (tid === 'detail-body' && !inlineTerm) {
            e.detail.target.scrollTop = e.detail.target.scrollHeight;
        }
    });

    // --- Terminal modal removed (PTY model has no full-session view) ---
    // attachTerminal() is a no-op now; the terminal modal HTML is kept for
    // potential future per-worker fullscreen, but no connection code is needed.
    window.attachTerminal = function() {
        showToast('Full-session terminal not available in PTY mode', true);
    }

    window.closeTerminal = function() {
        document.getElementById('terminal-modal').style.display = 'none';
    }

    // Resize handler — only resize the active terminal
    window.addEventListener('resize', function() {
        if (activeTermWorker) {
            var entry = termCache.get(activeTermWorker);
            if (entry && entry.fitAddon && entry.term) {
                entry.fitAddon.fit();
                sendResizeIfChanged(activeTermWorker, entry);
            }
        }
    });

    // Escape key closes modals (priority order: topmost first)
    document.addEventListener('keydown', function(e) {
        if (e.key !== 'Escape') return;
        // Skip if inline terminal textarea is focused
        if (inlineTerm && inlineTerm.textarea && document.activeElement === inlineTerm.textarea) return;

        // Check modals in priority order, close first visible one
        var decisionEl = document.getElementById('decision-modal');
        if (decisionEl && decisionEl.style.display !== 'none') { hideDecisionModal(); return; }
        var confirmEl = document.getElementById('confirm-modal');
        if (confirmEl && confirmEl.style.display !== 'none') { hideConfirm(); return; }
        var taskEl = document.getElementById('task-modal');
        if (taskEl && taskEl.style.display !== 'none') { closeTaskModal(); return; }
        var broadcastEl = document.getElementById('broadcast-modal');
        if (broadcastEl && broadcastEl.style.display !== 'none') { hideBroadcast(); return; }
        var queenEl = document.getElementById('queen-modal');
        if (queenEl && queenEl.style.display !== 'none') { hideQueen(); return; }
        var launchEl = document.getElementById('launch-modal');
        if (launchEl && launchEl.style.display !== 'none') { hideLaunch(); return; }
        var spawnEl = document.getElementById('spawn-modal');
        if (spawnEl && spawnEl.style.display !== 'none') { hideSpawn(); return; }
        var tunnelEl = document.getElementById('tunnel-modal');
        if (tunnelEl && tunnelEl.style.display !== 'none') { hideTunnel(); return; }
        var shutdownEl = document.getElementById('shutdown-modal');
        if (shutdownEl && shutdownEl.style.display !== 'none') { hideShutdown(); return; }
        // Terminal modal: only close when terminal not focused
        if (document.getElementById('terminal-modal').style.display !== 'none') {
            if (!term || !term.textarea || document.activeElement !== term.textarea) {
                closeTerminal();
            }
        }
    });

    // --- Resizable split ---
    ;(function() {
        const handle = document.getElementById('resize-handle');
        if (!handle) return;
        const area = handle.parentElement; // .detail-area
        let dragging = false;
        let startY = 0;
        let startTopFr = 0.5;

        // Read saved ratio
        const saved = localStorage.getItem('swarm-split');
        if (saved) {
            const ratio = parseFloat(saved);
            if (ratio > 0.15 && ratio < 0.85) {
                area.style.gridTemplateRows = ratio + 'fr auto ' + (1 - ratio) + 'fr';
            }
        }

        function startDrag(clientY) {
            dragging = true;
            startY = clientY;
            const rect = area.getBoundingClientRect();
            startTopFr = (area.children[0].getBoundingClientRect().height) / rect.height;
            handle.classList.add('dragging');
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
        }

        function moveDrag(clientY) {
            if (!dragging) return;
            const rect = area.getBoundingClientRect();
            const dy = clientY - rect.top;
            let ratio = dy / rect.height;
            ratio = Math.max(0.15, Math.min(0.85, ratio));
            area.style.gridTemplateRows = ratio + 'fr auto ' + (1 - ratio) + 'fr';
            // Fit inline terminal during drag (visual only, no WS resize flood)
            if (activeTermWorker) {
                var dragEntry = termCache.get(activeTermWorker);
                if (dragEntry && dragEntry.fitAddon && dragEntry.term) {
                    dragEntry.fitAddon.fit();
                }
            }
        }

        function endDrag() {
            if (!dragging) return;
            dragging = false;
            handle.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            // Persist
            const rect = area.getBoundingClientRect();
            const topH = area.children[0].getBoundingClientRect().height;
            localStorage.setItem('swarm-split', (topH / rect.height).toFixed(3));
            // Send final resize to inline terminal after drag ends
            if (activeTermWorker) {
                var endEntry = termCache.get(activeTermWorker);
                if (endEntry && endEntry.fitAddon && endEntry.term) {
                    endEntry.fitAddon.fit();
                    sendResizeIfChanged(activeTermWorker, endEntry);
                }
            }
        }

        // Mouse events (desktop)
        handle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            startDrag(e.clientY);
        });
        document.addEventListener('mousemove', function(e) { moveDrag(e.clientY); });
        document.addEventListener('mouseup', endDrag);

        // Touch events (mobile)
        handle.addEventListener('touchstart', function(e) {
            e.preventDefault();
            startDrag(e.touches[0].clientY);
        }, { passive: false });
        document.addEventListener('touchmove', function(e) {
            if (!dragging) return;
            e.preventDefault();
            moveDrag(e.touches[0].clientY);
        }, { passive: false });
        document.addEventListener('touchend', endDrag);
    })();
})();
</script>
{% endblock %}
